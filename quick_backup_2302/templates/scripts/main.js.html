<!-- ============================================================================
     GUST Bot Enhanced - Core JavaScript
     ============================================================================
     Extracted from enhanced_dashboard.html on 2025-06-17 12:20:33
     
     This file contains all the core JavaScript functionality including:
     - Tab switching logic
     - Global variables and utilities
     - Event handlers and initialization
     ============================================================================ -->

<script>
// Core JavaScript functionality extracted from enhanced_dashboard.html
let currentTab = 'dashboard';
        let messageTypeFilter = 'all';
        let serverFilter = '';
        let autoScroll = true;
        let connectionStatus = {};
        let websocketsAvailable = false;
        let managedServers = []; // Central server list
        let selectedServers = new Set(); // For bulk operations
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadManagedServers(); // Load servers first and auto-connect
            updateSystemStatus();
            startPolling();
            
            // Initialize live console functionality
            setTimeout(() => {
                if (websocketsAvailable) {
                    console.log('🚀 Initializing live console functionality with auto-connect...');
                    refreshConsoleWithLiveMessages();
                }
            }, 2000); // Increased delay to allow auto-connections to establish
            
            // Setup event listeners
            const messageTypeSelect = document.getElementById('messageTypeFilter');
            if (messageTypeSelect) {
                messageTypeSelect.addEventListener('change', function() {
                    messageTypeFilter = this.value;
                    refreshLiveMessages();
                });
            }
            
            const serverFilterSelect = document.getElementById('serverFilter');
            if (serverFilterSelect) {
                serverFilterSelect.addEventListener('change', function() {
                    serverFilter = this.value;
                    refreshLiveMessages();
                });
            }
            
            const autoScrollCheck = document.getElementById('autoScroll');
            if (autoScrollCheck) {
                autoScrollCheck.addEventListener('change', function() {
                    autoScroll = this.checked;
                });
            }
            
            // Console-specific event listeners
            setTimeout(() => {
                const consoleMessageTypeFilter = document.getElementById('consoleMessageTypeFilter');
                if (consoleMessageTypeFilter) {
                    consoleMessageTypeFilter.addEventListener('change', function() {
                        messageTypeFilter = this.value;
                        refreshConsoleWithLiveMessages();
                    });
                }
                
                const monitorServerFilter = document.getElementById('monitorServerFilter');
                if (monitorServerFilter) {
                    monitorServerFilter.addEventListener('change', function() {
                        serverFilter = this.value;
                        refreshConsoleWithLiveMessages();
                    });
                }
                
                const consoleAutoScrollCheck = document.getElementById('consoleAutoScroll');
                if (consoleAutoScrollCheck) {
                    consoleAutoScrollCheck.addEventListener('change', function() {
                        autoScroll = this.checked;
                    });
                }
            }, 100);
            
            // Enter key support
            setTimeout(() => {
                const liveCommandInput = document.getElementById('liveCommandInput');
                if (liveCommandInput) {
                    liveCommandInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') sendLiveCommand();
                    });
                }
                
                const consoleInput = document.getElementById('consoleInput');
                if (consoleInput) {
                    consoleInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') sendConsoleCommand();
                    });
                }
                
                // Server form enter key support
                const serverFormInputs = ['newServerId', 'newServerName', 'newServerDescription'];
                serverFormInputs.forEach(inputId => {
                    const input = document.getElementById(inputId);
                    if (input) {
                        input.addEventListener('keypress', function(e) {
                            if (e.key === 'Enter') addNewServer();
                        });
                    }
                });
            }, 100);
        });
        
        function showTab(tabId) {
    console.log('🔄 Switching to tab:', tabId);
    
    try {
        // Hide all views
        document.querySelectorAll('.view').forEach(view => {
            if (view) {
                view.style.display = 'none';
                view.classList.remove('active');
                view.classList.add('hidden');
            }
        });
        
        // Remove active class from all nav tabs
        document.querySelectorAll('.nav-tab').forEach(tab => {
            if (tab && tab.classList) {
                tab.classList.remove('active');
            }
        });
        
        // Show target view
        const targetView = document.getElementById(tabId);
        if (targetView) {
            targetView.style.display = 'block';
            targetView.classList.add('active');
            targetView.classList.remove('hidden');
            console.log('✅ Showing view:', tabId);
        } else {
            console.warn('⚠️ View not found:', tabId);
            // Try alternative ID patterns
            const alternativeView = document.getElementById(tabId + '-view');
            if (alternativeView) {
                alternativeView.style.display = 'block';
                alternativeView.classList.add('active');
                alternativeView.classList.remove('hidden');
                console.log('✅ Showing alternative view:', tabId + '-view');
            } else {
                console.error('❌ No view found for:', tabId);
                return;
            }
        }
        
        // Activate corresponding nav tab
        const navTab = document.getElementById(tabId + '-tab');
        if (navTab && navTab.classList) {
            navTab.classList.add('active');
        }
        
        // Initialize tab if initializer exists
        if (typeof window.tabInitializers === 'object' && window.tabInitializers[tabId]) {
            try {
                console.log('🔧 Initializing tab:', tabId);
                window.tabInitializers[tabId]();
            } catch (initError) {
                console.error('❌ Tab initialization error for', tabId, ':', initError);
            }
        }
        
        console.log('✅ Tab switch complete:', tabId);
        
    } catch (error) {
        console.error('❌ showTab error:', error);
        console.error('   Tab ID:', tabId);
        console.error('   Stack:', error.stack);
    }
}
        
        // ===========================================
        // LIVE CONSOLE FIXES - Enhanced Functions
        // ===========================================
        
        // ENHANCED CONSOLE REFRESH WITH LIVE MESSAGES
        async function refreshConsoleWithLiveMessages() {
            try {
                // Get regular console output
                const consoleResponse = await fetch('/api/console/output');
                const consoleOutput = await consoleResponse.json();
                
                // Get live messages  
                const params = new URLSearchParams();
                if (serverFilter) params.append('serverId', serverFilter);
                if (messageTypeFilter !== 'all') params.append('type', messageTypeFilter);
                params.append('limit', '30');
                
                const liveResponse = await fetch(`/api/console/live/messages?${params}`);
                const liveData = await liveResponse.json();
                
                // Combine and display messages
                displayCombinedConsoleOutput(consoleOutput, liveData.messages || []);
                
            } catch (error) {
                console.error('Error refreshing console with live messages:', error);
                refreshConsole(); // Fallback
            }
        }
        
        // DISPLAY COMBINED CONSOLE OUTPUT (COMMANDS + LIVE MESSAGES)
        function displayCombinedConsoleOutput(consoleOutput, liveMessages) {
            const outputDiv = document.getElementById('consoleOutput');
            if (!outputDiv) return;
            
            const wasScrolledToBottom = outputDiv.scrollTop + outputDiv.clientHeight >= outputDiv.scrollHeight - 10;
            
            // Clear and add header
            outputDiv.innerHTML = '<div class="text-green-400">GUST Bot Console - Ready (Commands + Live Messages)</div>';
            
            // Add console command output
            consoleOutput.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'mb-1 text-sm';
                
                if (entry.command) {
                    div.className += ' text-blue-400 font-mono';
                    div.textContent = `> ${entry.command}`;
                } else {
                    div.className += entry.status === 'server_response' ? ' text-white' : ' text-gray-400';
                    div.textContent = entry.message;
                }
                
                outputDiv.appendChild(div);
            });
            
            // Add live messages if any
            if (liveMessages.length > 0) {
                // Add separator
                const separator = document.createElement('div');
                separator.className = 'text-yellow-400 text-sm border-t border-gray-600 pt-2 mt-2';
                separator.textContent = '📺 Live Console Messages:';
                outputDiv.appendChild(separator);
                
                // Add live messages
                liveMessages.forEach(message => {
                    const div = document.createElement('div');
                    div.className = 'console-live-message text-sm mb-1 pl-2 border-l-2 border-blue-500';
                    
                    const time = new Date(message.timestamp).toLocaleTimeString();
                    const type = message.type || 'system';
                    const serverId = message.server_id || message.serverId || '';
                    
                    // Format the message with timestamp and type
                    const typeIcon = getTypeIcon(type);
                    const serverInfo = serverId ? ` [${serverId}]` : '';
                    
                    div.innerHTML = `
                        <span class="text-gray-500 text-xs">[${time}]</span>
                        <span class="text-xs bg-gray-700 px-1 rounded">${typeIcon} ${type}</span>
                        ${serverInfo ? `<span class="text-xs text-gray-400">${serverInfo}</span>` : ''}
                        <div class="text-gray-200 font-mono mt-1">${escapeHtml(message.message)}</div>
                    `;
                    
                    outputDiv.appendChild(div);
                });
            }
            
            // Auto-scroll if needed
            if (autoScroll && wasScrolledToBottom) {
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        }
        
        // TEST FUNCTION FOR LIVE CONSOLE
        async function testLiveConsole() {
            try {
                const response = await fetch('/api/console/live/test');
                const data = await response.json();
                
                const alertMsg = `Live Console Test Results:
                
✅ Success: ${data.success}
🔌 WebSockets Available: ${data.websockets_available}
📡 Active Connections: ${data.total_connections || 0}
📨 Recent Messages: ${data.message_count || 0}

${data.recent_messages && data.recent_messages.length > 0 ? 
  'Latest Message: ' + (data.recent_messages[data.recent_messages.length-1].message || 'N/A').substring(0, 100) : 
  'No recent messages'}

${data.error ? 'Error: ' + data.error : 'Working!'}`;
                
                alert(alertMsg);
                console.log('🔍 Live Console Test Data:', data);
                
                // Also refresh the console after test
                if (currentTab === 'console') {
                    refreshConsoleWithLiveMessages();
                }
                
            } catch (error) {
                alert(`Test Error: ${error.message}`);
                console.error('Test error:', error);
            }
        }
        
        // ===========================================
        // CENTRALIZED SERVER MANAGEMENT FUNCTIONS
        // ===========================================
        
                async function loadManagedServers() {
            try {
                const response = await fetch('/api/servers');
                let servers = await response.json();
                
                // CRITICAL FIX: Store in both local AND global variables
                managedServers = servers;
                window.managedServers = servers;  // ← THIS IS THE KEY FIX
                
                // If no servers found, create demo servers for testing
                if (servers.length === 0) {
                    console.log('🎭 No servers found, creating demo servers...');
                    servers = await createDemoServersIfNeeded();
                    managedServers = servers;
                    window.managedServers = servers;
                }
                
                // Update all server dropdowns
                updateAllServerDropdowns();
                
                // Auto-connect to all active servers for live monitoring
                await autoConnectToAllServers();
                
                console.log('Loaded servers:', managedServers.length);
            } catch (error) {
                console.error('Error loading managed servers:', error);
                managedServers = [];
                window.managedServers = [];  // ← Also set global to empty array
            }
        }
        
        async function autoConnectToAllServers() {
            if (!websocketsAvailable) {
                console.log('WebSockets not available - skipping auto-connect');
                return;
            }
            
            // Connect to all active servers
            for (const server of managedServers) {
                if (server.isActive) {
                    await autoConnectToServer(server);
                    // Small delay between connections to avoid overwhelming
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
        }
        
        async function autoConnectToServer(server) {
            try {
                console.log(`🔄 Auto-connecting to ${server.serverName} (${server.serverId})`);
                
                const response = await fetch('/api/console/live/connect', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        serverId: server.serverId,
                        region: server.serverRegion
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log(`✅ Auto-connected to ${server.serverName}`);
                    addLiveConsoleMessage({
                        timestamp: new Date().toISOString(),
                        message: `🔄 Auto-connected to ${server.serverName} for live monitoring`,
                        type: 'system',
                        source: 'auto_connection'
                    });
                } else {
                    console.log(`❌ Auto-connect failed for ${server.serverName}: ${result.error}`);
                    // Only show error message if not in demo mode
                    if (!result.error.includes('Demo mode') && !result.error.includes('demo')) {
                        addLiveConsoleMessage({
                            timestamp: new Date().toISOString(),
                            message: `⚠️ Auto-connect failed for ${server.serverName}: ${result.error}`,
                            type: 'warning',
                            source: 'auto_connection'
                        });
                    }
                }
            } catch (error) {
                console.error(`Error auto-connecting to ${server.serverName}:`, error);
            }
        }
        
        function updateAllServerDropdowns() {
            // List of all server dropdown IDs in the application (removed liveConnectionServerSelect)
            const serverDropdowns = [
                'consoleServerSelect',
                'eventServerSelect', 
                'clanServerSelect',
                'banServerSelect',
                'giveItemServerSelect',
                'liveTargetServer',
                'serverFilter',
				'userMgmtServerSelect'
            ];
            
            serverDropdowns.forEach(dropdownId => {
                const dropdown = document.getElementById(dropdownId);
                if (!dropdown) return;
                
                const currentValue = dropdown.value;
                
                // Clear existing options except the first one
                const firstOption = dropdown.querySelector('option:first-child');
                dropdown.innerHTML = '';
                if (firstOption) {
                    dropdown.appendChild(firstOption);
                }
                
                // Add server options
                managedServers.filter(server => server.isActive).forEach(server => {
                    const option = document.createElement('option');
                    option.value = server.serverId;
                    option.textContent = `${server.serverName} (${server.serverId}) - ${server.serverRegion}`;
                    
                    // Add status indicator
                    if (server.status === 'online') {
                        option.textContent += ' ✅';
                    } else if (server.status === 'offline') {
                        option.textContent += ' ❌';
                    }
                    
                    dropdown.appendChild(option);
                });
                
                // Restore previous selection if still valid
                if (currentValue) {
                    dropdown.value = currentValue;
                }
            });
        }
        
        function getServerById(serverId) {
            return managedServers.find(server => server.serverId === serverId);
        }
        
        function getServerRegion(serverId) {
            const server = getServerById(serverId);
            return server ? server.serverRegion : 'US';
        }
        
        async function addNewServer() {
            const serverId = document.getElementById('newServerId').value.trim();
            const serverName = document.getElementById('newServerName').value.trim();
            const serverRegion = document.getElementById('newServerRegion').value;
            const serverType = document.getElementById('newServerType').value;
            const description = document.getElementById('newServerDescription').value.trim();
            
            if (!serverId || !serverName) {
                alert('Please fill in Server ID and Server Name (required fields)');
                return;
            }
            
            // Check if server already exists
            if (managedServers.find(s => s.serverId === serverId)) {
                alert('A server with this ID already exists!');
                return;
            }
            
            try {
                const response = await fetch('/api/servers/add', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        serverId,
                        serverName,
                        serverRegion,
                        serverType,
                        description
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('✅ Server added successfully!');
                    clearServerForm();
                    await loadManagedServers(); // Reload server list and auto-connect
                    loadServerManager(); // Refresh the server manager view
                } else {
                    alert('❌ Failed to add server: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                alert('❌ Error adding server: ' + error.message);
            }
        }
        
        function clearServerForm() {
            document.getElementById('newServerId').value = '';
            document.getElementById('newServerName').value = '';
            document.getElementById('newServerDescription').value = '';
            document.getElementById('newServerRegion').value = 'US';
            document.getElementById('newServerType').value = 'Standard';
        }
        
        function loadServerManager() {
            refreshServerList();
        }
        
        function refreshServerList() {
            const container = document.getElementById('managedServersList');
            
            if (managedServers.length === 0) {
                container.innerHTML = `
                    <div class="text-gray-400 text-center py-8">
                        <div class="text-4xl mb-4">🔍</div>
                        <div>No servers found</div>
                        <div class="text-sm mt-2">Add a new server above to get started</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = managedServers.map(server => `
                <div class="bg-gray-700 p-4 rounded-lg border border-gray-600">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-4">
                            <div>
                                <div class="flex items-center space-x-2">
                                    <h4 class="font-semibold text-lg">${server.serverName}</h4>
                                    ${server.isFavorite ? '<span class="text-yellow-400">⭐</span>' : ''}
                                    ${!server.isActive ? '<span class="text-red-400 text-xs bg-red-900 px-2 py-1 rounded">INACTIVE</span>' : ''}
                                </div>
                                <div class="text-sm text-gray-300">
                                    ID: ${server.serverId} | Region: ${server.serverRegion} | Type: ${server.serverType || 'Standard'}
                                </div>
                                ${server.description ? `<div class="text-xs text-gray-400 mt-1">${server.description}</div>` : ''}
                            </div>
                        </div>
                        
                        <div class="flex items-center space-x-2">
                            <!-- Status Indicator -->
                            <div class="flex items-center space-x-2">
                                <span class="text-xs px-2 py-1 rounded ${getStatusClass(server.status)}">
                                    ${getStatusText(server.status)}
                                </span>
                                ${server.lastPing ? `<span class="text-xs text-gray-400">Pinged: ${new Date(server.lastPing).toLocaleTimeString()}</span>` : ''}
                            </div>
                            
                            <!-- Quick Actions -->
                            <button onclick="pingSingleServer('${server.serverId}')" 
                                    class="bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded text-xs" title="Ping Server">
                                📡
                            </button>
                            <button onclick="connectToLiveConsole('${server.serverId}')" 
                                    class="bg-green-600 hover:bg-green-700 px-2 py-1 rounded text-xs" title="Connect Live Console">
                                📺
                            </button>
                            <button onclick="deleteServer('${server.serverId}')" 
                                    class="bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-xs" title="Delete Server">
                                🗑️
                            </button>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function getStatusClass(status) {
            switch(status) {
                case 'online': return 'bg-green-800 text-green-200';
                case 'offline': return 'bg-red-800 text-red-200';
                default: return 'bg-gray-700 text-gray-300';
            }
        }
        
        function getStatusText(status) {
            switch(status) {
                case 'online': return '🟢 Online';
                case 'offline': return '🔴 Offline';
                default: return '⚪ Unknown';
            }
        }
        
        async function pingSingleServer(serverId) {
            try {
                const response = await fetch(`/api/servers/ping/${serverId}`, {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    // Update server status in local list
                    const server = managedServers.find(s => s.serverId === serverId);
                    if (server) {
                        server.status = result.status;
                        server.lastPing = new Date().toISOString();
                    }
                    refreshServerList();
                    updateAllServerDropdowns();
                } else {
                    alert('Failed to ping server');
                }
            } catch (error) {
                alert('Error pinging server: ' + error.message);
            }
        }
        
        async function connectToLiveConsole(serverId) {
            // Just switch to console tab since auto-connection handles the connection
            showTab('console');
            
            addLiveConsoleMessage({
                timestamp: new Date().toISOString(),
                message: `📺 Switched to console view. Server ${serverId} is auto-connected for live monitoring.`,
                type: 'system',
                source: 'navigation'
            });
        }
        
        async function deleteServer(serverId) {
            const server = getServerById(serverId);
            if (!server) return;
            
            if (!confirm(`Are you sure you want to delete "${server.serverName}"?

This will:
• Remove the server from all tabs
• Disconnect any live console connections
• This action cannot be undone`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/servers/delete/${serverId}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Remove from local list
                    managedServers = managedServers.filter(s => s.serverId !== serverId);
                    
                    refreshServerList();
                    updateAllServerDropdowns();
                    
                    alert('✅ Server deleted successfully');
                } else {
                    alert('❌ Failed to delete server');
                }
            } catch (error) {
                alert('❌ Error deleting server: ' + error.message);
            }
        }
        
        function initializeConsole() {
            refreshConsoleWithLiveMessages();
            updateLiveConnectionStatus();
            updateConsoleFilters();
        }
        
        function updateConsoleFilters() {
            // Update monitor server filter with connected servers
            const monitorFilter = document.getElementById('monitorServerFilter');
            if (monitorFilter) {
                const currentValue = monitorFilter.value;
                monitorFilter.innerHTML = '<option value="">🌐 All Connected Servers</option>';
                
                Object.keys(connectionStatus).forEach(serverId => {
                    const server = getServerById(serverId);
                    const serverName = server ? server.serverName : `Server ${serverId}`;
                    const option = document.createElement('option');
                    option.value = serverId;
                    option.textContent = `${serverName} (${serverId})`;
                    monitorFilter.appendChild(option);
                });
                
                if (currentValue) {
                    monitorFilter.value = currentValue;
                }
            }
        }
        
        function clearConsole() {
            const outputDiv = document.getElementById('consoleOutput');
            if (outputDiv) {
                outputDiv.innerHTML = '<div class="text-green-400">GUST Bot Console - Cleared</div>';
            }
        }
        
        function loadDashboard() {
            // Use managed servers count
            document.getElementById('activeServers').textContent = managedServers.length;
            
            fetch('/api/events').then(r => r.json()).then(events => {
                document.getElementById('activeEvents').textContent = events.length;
            }).catch(e => console.error('Error loading events:', e));
            
            fetch('/api/clans').then(r => r.json()).then(clans => {
                document.getElementById('totalClans').textContent = clans.length;
            }).catch(e => console.error('Error loading clans:', e));
            
            updateSystemStatus();
        }
        
        function updateSystemStatus() {
            // Check token status
            fetch('/api/token/status').then(r => r.json()).then(data => {
                const dbStatus = document.getElementById('dbStatus');
                const tokenStatus = document.getElementById('tokenStatus');
                const modeStatus = document.getElementById('modeStatus');
                const websocketStatus = document.getElementById('websocketStatus');
                const refreshBtn = document.getElementById('refreshTokenBtn');
                
                websocketsAvailable = data.websockets_available;
                
                if (data.demo_mode) {
                    tokenStatus.textContent = '• G-Portal Token: Demo Mode';
                    modeStatus.textContent = '• Mode: Demo (simulated commands)';
                    if (refreshBtn) refreshBtn.classList.add('hidden');
                } else if (data.has_token && data.token_valid) {
                    tokenStatus.textContent = `• G-Portal Token: Valid (${Math.floor(data.time_left/60)}m left)`;
                    modeStatus.textContent = '• Mode: Live (real G-Portal API)';
                    if (refreshBtn) refreshBtn.classList.add('hidden');
                } else {
                    tokenStatus.textContent = '• G-Portal Token: Expired/Invalid';
                    modeStatus.textContent = '• Mode: Needs authentication';
                    if (refreshBtn) refreshBtn.classList.remove('hidden');
                }
                
                if (websocketStatus) {
                    websocketStatus.textContent = `• WebSocket Support: ${websocketsAvailable ? 'Available ✅' : 'Not Available ❌'}`;
                }
                
                // Update live console description based on WebSocket availability
                const liveConsoleDesc = document.getElementById('liveConsoleDescription');
                const liveConsoleFeatures = document.getElementById('liveConsoleFeatures');
                const websocketStatusDetail = document.getElementById('websocketStatusDetail');
                
                if (!websocketsAvailable) {
                    if (liveConsoleDesc) {
                        liveConsoleDesc.textContent = 'WebSocket support not available. Install with: pip install websockets';
                        liveConsoleDesc.className = 'text-red-200 mb-3';
                    }
                    if (liveConsoleFeatures) {
                        liveConsoleFeatures.innerHTML = `
                            <li>• Install websockets: pip install websockets</li>
                            <li>• Then restart the application</li>
                            <li>• Command console still works normally</li>
                            <li>• Live monitoring will be available after install</li>
                        `;
                    }
                    if (websocketStatusDetail) {
                        websocketStatusDetail.innerHTML = `
                            <div class="text-red-300">WebSocket support not available</div>
                            <div class="mt-1">Install: pip install websockets</div>
                        `;
                    }
                } else {
                    if (websocketStatusDetail) {
                        websocketStatusDetail.innerHTML = `
                            <div class="text-green-300">WebSocket support available</div>
                            <div class="mt-1">Live console ready</div>
                        `;
                    }
                }
            }).catch(e => console.error('Error checking token status:', e));
            
            // Check health
            fetch('/health').then(r => r.json()).then(data => {
                const dbStatus = document.getElementById('dbStatus');
                const liveConnections = document.getElementById('liveConnections');
                
                if (dbStatus) {
                    dbStatus.textContent = '• Database: ' + data.database;
                }
                
                if (liveConnections) {
                    liveConnections.textContent = data.live_connections || 0;
                }
            }).catch(e => console.error('Error checking health:', e));
        }
        
        function startPolling() {
            // Poll for live messages every 3 seconds when on console tab
            setInterval(() => {
                if (currentTab === 'console') {
                    updateLiveConnectionStatus();
                    updateConsoleFilters();
                    refreshConsoleWithLiveMessages(); // FIXED: Auto-refresh live messages
                }
            }, 3000);
            
            // Auto-reconnect check every 30 seconds
            setInterval(() => {
                if (websocketsAvailable && managedServers.length > 0) {
                    checkAndReconnectServers();
                }
            }, 30000);
            
            // Poll for system status every 30 seconds
            setInterval(updateSystemStatus, 30000);
            
            // Refresh server list every 2 minutes
            setInterval(() => {
                if (currentTab === 'server-manager') {
                    loadManagedServers();
                }
            }, 120000);
        }
        
        async function checkAndReconnectServers() {
            // Check connection status and reconnect if needed
            try {
                const response = await fetch('/api/console/live/status');
                const data = await response.json();
                
                const connectedServerIds = Object.keys(data.connections || {});
                const activeServerIds = managedServers.filter(s => s.isActive).map(s => s.serverId);
                
                // Find servers that should be connected but aren't
                for (const serverId of activeServerIds) {
                    if (!connectedServerIds.includes(serverId)) {
                        const server = getServerById(serverId);
                        if (server) {
                            console.log(`🔄 Auto-reconnecting to ${server.serverName}`);
                            await autoConnectToServer(server);
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking connections for auto-reconnect:', error);
            }
        }
        
        // Live Console Functions - Auto-Connect Mode
        function addLiveConsoleMessage(message, shouldScroll = true) {
            // This function is used to add connection status messages to the console
            // For now, we'll add them to the regular console output
            const outputDiv = document.getElementById('consoleOutput');
            if (!outputDiv) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'text-blue-300 text-sm mb-1';
            
            const time = new Date(message.timestamp).toLocaleTimeString();
            messageDiv.textContent = `[${time}] ${message.message}`;
            
            outputDiv.appendChild(messageDiv);
            
            if (shouldScroll && autoScroll) {
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        }
        
        async function updateLiveConnectionStatus() {
            try {
                const response = await fetch('/api/console/live/status');
                const data = await response.json();
                
                connectionStatus = data.connections;
                
                // Update live indicator in sidebar
                const indicator = document.getElementById('liveIndicator');
                const totalConnections = Object.keys(connectionStatus).length;
                const activeConnections = Object.values(connectionStatus).filter(c => c.connected).length;
                
                if (indicator) {
                    if (activeConnections > 0) {
                        indicator.innerHTML = `
                            <div class="w-3 h-3 bg-green-500 rounded-full mr-2 live-indicator"></div>
                            <span class="text-xs">Live (${activeConnections})</span>
                        `;
                    } else {
                        indicator.innerHTML = `
                            <div class="w-3 h-3 bg-gray-500 rounded-full mr-2"></div>
                            <span class="text-xs">Ready</span>
                        `;
                    }
                }
                
                // Update connection stats in console
                const activeCountElement = document.getElementById('activeConnectionCount');
                if (activeCountElement) {
                    activeCountElement.textContent = activeConnections;
                }
                
                // Update active connections display
                const connectionsDiv = document.getElementById('liveActiveConnections');
                if (connectionsDiv) {
                    if (totalConnections === 0) {
                        connectionsDiv.innerHTML = '<div class="text-gray-400 text-sm text-center py-4">No active connections</div>';
                    } else {
                        connectionsDiv.innerHTML = Object.entries(connectionStatus).map(([serverId, status]) => {
                            const server = getServerById(serverId);
                            const serverName = server ? server.serverName : `Server ${serverId}`;
                            const serverRegion = server ? server.serverRegion : 'Unknown';
                            
                            return `
                            <div class="flex items-center justify-between p-2 bg-gray-600 rounded mb-2">
                                <div class="flex-1">
                                    <div class="text-sm font-medium">${serverName}</div>
                                    <div class="text-xs text-gray-300">${serverId} - ${serverRegion}</div>
                                    <div class="text-xs ${status.connected ? 'text-green-400' : 'text-red-400'}">
                                        ${status.connected ? '● Live Connected' : '○ Disconnected'}
                                    </div>
                                </div>
                                <button onclick="disconnectServer('${serverId}')" 
                                        class="text-red-400 hover:text-red-300 text-xs p-1" title="Disconnect">✕</button>
                            </div>
                        `}).join('');
                    }
                }
                
                // Update console filters
                updateConsoleFilters();
                
            } catch (error) {
                console.error('Error updating connection status:', error);
            }
        }
        
        async function disconnectServer(serverId) {
            try {
                const response = await fetch('/api/console/live/disconnect', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ serverId: serverId })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addLiveConsoleMessage({
                        timestamp: new Date().toISOString(),
                        message: `🔌 Disconnected from server ${serverId}`,
                        type: 'system',
                        source: 'connection'
                    });
                    updateLiveConnectionStatus();
                } else {
                    addLiveConsoleMessage({
                        timestamp: new Date().toISOString(),
                        message: `❌ Failed to disconnect from server ${serverId}: ${result.error}`,
                        type: 'error',
                        source: 'connection'
                    });
                }
            } catch (error) {
                addLiveConsoleMessage({
                    timestamp: new Date().toISOString(),
                    message: `❌ Disconnect error for server ${serverId}: ${error.message}`,
                    type: 'error',
                    source: 'connection'
                });
            }
        }
        
        // Console Functions - Updated to use centralized servers
        function setCommand(command) {
            const consoleInput = document.getElementById('consoleInput');
            if (consoleInput) {
                consoleInput.value = command;
            }
        }
        
        async function sendConsoleCommand() {
            const command = document.getElementById('consoleInput').value.trim();
            const serverSelect = document.getElementById('consoleServerSelect');
            const serverId = serverSelect.value;
            
            if (!command) {
                alert('Please enter a command');
                return;
            }
            
            if (!serverId) {
                alert('Please select a server from the dropdown');
                return;
            }
            
            const region = getServerRegion(serverId);
            const outputDiv = document.getElementById('consoleOutput');
            
            // Add command to output
            addCommandOutput(`> ${command} (Server: ${serverId})`, 'command');
            
            try {
                const response = await fetch('/api/console/send', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        command: command,
                        serverId: serverId,
                        region: region
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addCommandOutput(`✅ Command sent successfully to ${getServerById(serverId)?.serverName || serverId}`, 'success');
                    document.getElementById('consoleInput').value = '';
                    
                    // Auto-refresh to show new messages
                    setTimeout(() => {
                        refreshConsoleWithLiveMessages();
                    }, 1000);
                } else {
                    addCommandOutput(`❌ Command failed: ${result.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                addCommandOutput(`❌ Send error: ${error.message}`, 'error');
            }
        }
        
        function addCommandOutput(message, type) {
            const outputDiv = document.getElementById('consoleOutput');
            if (!outputDiv) return;
            
            const time = new Date().toLocaleTimeString();
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `mb-2 ${type === 'error' ? 'text-red-400' : type === 'success' ? 'text-green-400' : 'text-gray-300'}`;
            messageDiv.innerHTML = `<span class="text-gray-500">[${time}]</span> ${message}`;
            
            outputDiv.appendChild(messageDiv);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }
        
        function refreshConsole() {
            // Fallback console refresh (basic version)
            fetch('/api/console/output').then(r => r.json()).then(output => {
                const outputDiv = document.getElementById('consoleOutput');
                if (!outputDiv) return;
                
                outputDiv.innerHTML = '<div class="text-green-400">GUST Bot Console - Ready</div>';
                output.forEach(entry => {
                    const div = document.createElement('div');
                    if (entry.command) {
                        div.className = 'text-blue-400';
                        div.textContent = `> ${entry.command}`;
                    } else {
                        div.className = entry.status === 'server_response' ? 'text-white' : 'text-gray-400';
                        div.textContent = entry.message;
                    }
                    outputDiv.appendChild(div);
                });
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }).catch(e => console.error('Error refreshing console:', e));
        }
        
        // Helper Functions
        function getTypeIcon(type) {
            const icons = {
                'chat': '💬',
                'auth': '🔐',
                'save': '💾',
                'kill': '⚔️',
                'error': '❌',
                'warning': '⚠️',
                'command': '🔧',
                'player': '👥',
                'system': '🖥️',
                'event': '🎯',
                'ban': '🚫'
            };
            return icons[type] || '📋';
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Event Management Functions - Updated to use centralized servers
        function loadEvents() {
            fetch('/api/events').then(r => r.json()).then(events => {
                const list = document.getElementById('activeEventsList');
                if (!list) return;
                
                list.innerHTML = '';
                events.forEach(event => {
                    const server = getServerById(event.serverId);
                    const serverName = server ? server.serverName : `Server ${event.serverId}`;
                    
                    const div = document.createElement('div');
                    div.className = 'bg-gray-700 p-3 rounded mb-2';
                    div.innerHTML = `
                        <div class="font-semibold">${event.type.toUpperCase()} Event</div>
                        <div class="text-sm text-gray-300">Server: ${serverName} (${event.serverId})</div>
                        <div class="text-sm text-gray-300">Reward: ${event.reward}</div>
                        ${event.arena_location ? `<div class="text-sm text-gray-300">Location: ${event.arena_location}</div>` : ''}
                        <div class="text-xs text-green-400 mt-1">✅ Vanilla Compatible</div>
                    `;
                    list.appendChild(div);
                });
            }).catch(e => console.error('Error loading events:', e));
        }
        
        async function startKothEvent() {
            const serverSelect = document.getElementById('eventServerSelect');
            const serverId = serverSelect.value;
            const duration = parseInt(document.getElementById('eventDuration').value);
            const rewardItem = document.getElementById('eventRewardItem').value.trim();
            const rewardAmount = parseInt(document.getElementById('eventRewardAmount').value);
            const arenaLocation = document.getElementById('eventArenaLocation').value;
            
            if (!serverId) {
                alert('Please select a server from the dropdown');
                return;
            }
            
            const server = getServerById(serverId);
            if (!server) {
                alert('Selected server not found. Please refresh the page.');
                return;
            }
            
            try {
                const response = await fetch('/api/events/koth/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        serverId: serverId,
                        region: server.serverRegion,
                        duration: duration,
                        reward_item: rewardItem,
                        reward_amount: rewardAmount,
                        arena_location: arenaLocation
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert(`✅ KOTH event started successfully on ${server.serverName}!
Duration: ${duration} minutes
Location: ${arenaLocation}
Reward: ${rewardAmount} ${rewardItem}

Check console for announcements.`);
                    loadEvents();
                } else {
                    alert('❌ Failed to start event: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error starting event: ' + error.message);
            }
        }
        
        // Economy Functions
        async function lookupBalance() {
            const userId = document.getElementById('lookupUserId').value.trim();
            if (!userId) {
                alert('Please enter a user ID');
                return;
            }
            
            try {
                const response = await fetch(`/api/economy/balance/${userId}`);
                const result = await response.json();
                document.getElementById('balanceResult').textContent = `Balance: ${result.balance} coins`;
            } catch (error) {
                document.getElementById('balanceResult').textContent = `Error: ${error.message}`;
            }
        }
        
        async function transferCoins() {
            const fromUser = document.getElementById('fromUserId').value.trim();
            const toUser = document.getElementById('toUserId').value.trim();
            const amount = parseInt(document.getElementById('transferAmount').value);
            
            if (!fromUser || !toUser || !amount) {
                alert('Please fill all fields');
                return;
            }
            
            try {
                const response = await fetch('/api/economy/transfer', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        fromUserId: fromUser,
                        toUserId: toUser,
                        amount: amount
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('Transfer successful!');
                    document.getElementById('fromUserId').value = '';
                    document.getElementById('toUserId').value = '';
                    document.getElementById('transferAmount').value = '';
                } else {
                    alert('Transfer failed - insufficient balance');
                }
            } catch (error) {
                alert('Transfer error: ' + error.message);
            }
        }
        
        // Gambling Functions
        async function playSlots() {
            const userId = document.getElementById('slotsUserId').value.trim();
            const bet = parseInt(document.getElementById('slotsBet').value);
            
            if (!userId || !bet) {
                alert('Please fill all fields');
                return;
            }
            
            try {
                const response = await fetch('/api/gambling/slots', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({userId, bet})
                });
                
                const result = await response.json();
                
                if (result.success) {
                    document.getElementById('slotsResult').innerHTML = `
                        <div class="text-2xl mb-2">${result.result.join(' ')}</div>
                        <div class="${result.net_change > 0 ? 'text-green-400' : 'text-red-400'}">
                            ${result.net_change > 0 ? 'Won' : 'Lost'}: ${Math.abs(result.net_change)} coins
                        </div>
                        <div>New Balance: ${result.new_balance}</div>
                    `;
                } else {
                    document.getElementById('slotsResult').innerHTML = `<div class="text-red-400">${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('slotsResult').innerHTML = `<div class="text-red-400">Error: ${error.message}</div>`;
            }
        }
        
        async function playCoinflip() {
            const userId = document.getElementById('coinflipUserId').value.trim();
            const bet = parseInt(document.getElementById('coinflipBet').value);
            const choice = document.getElementById('coinflipChoice').value;
            
            if (!userId || !bet) {
                alert('Please fill all fields');
                return;
            }
            
            try {
                const response = await fetch('/api/gambling/coinflip', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({userId, amount: bet, choice})
                });
                
                const result = await response.json();
                
                if (result.success) {
                    document.getElementById('coinflipResult').innerHTML = `
                        <div>Result: ${result.result}</div>
                        <div class="${result.won ? 'text-green-400' : 'text-red-400'}">
                            ${result.won ? 'Won' : 'Lost'}: ${Math.abs(result.net_change)} coins
                        </div>
                        <div>New Balance: ${result.new_balance}</div>
                    `;
                } else {
                    document.getElementById('coinflipResult').innerHTML = `<div class="text-red-400">${result.error}</div>`;
                }
            } catch (error) {
                document.getElementById('coinflipResult').innerHTML = `<div class="text-red-400">Error: ${error.message}</div>`;
            }
        }
        
        // Clan Management Functions
        function loadClans() {
            fetch('/api/clans').then(r => r.json()).then(clans => {
                const list = document.getElementById('clansList');
                if (!list) return;
                
                list.innerHTML = '';
                clans.forEach(clan => {
                    const div = document.createElement('div');
                    div.className = 'bg-gray-700 p-3 rounded mb-2';
                    div.innerHTML = `
                        <div class="font-semibold">${clan.name}</div>
                        <div class="text-sm text-gray-300">Leader: ${clan.leader}</div>
                        <div class="text-sm text-gray-300">Members: ${clan.members.length}</div>
                    `;
                    list.appendChild(div);
                });
            }).catch(e => console.error('Error loading clans:', e));
        }
        
        async function createClan() {
            const name = document.getElementById('clanName').value.trim();
            const leader = document.getElementById('clanLeader').value.trim();
            const serverId = document.getElementById('clanServerSelect').value.trim();
            const description = document.getElementById('clanDescription').value.trim();
            
            if (!name || !leader || !serverId) {
                alert('Please fill required fields');
                return;
            }
            
            try {
                const response = await fetch('/api/clans/create', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, leader, serverId, description})
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('Clan created successfully!');
                    document.getElementById('clanName').value = '';
                    document.getElementById('clanLeader').value = '';
                    document.getElementById('clanServerSelect').value = '';
                    document.getElementById('clanDescription').value = '';
                    loadClans();
                } else {
                    alert('Failed to create clan');
                }
            } catch (error) {
                alert('Error creating clan: ' + error.message);
            }
        }
        
        // User Management Functions
        async function tempBanUser() {
            const userId = document.getElementById('banUserId').value.trim();
            const serverId = document.getElementById('banServerSelect').value.trim();
            const duration = parseInt(document.getElementById('banDuration').value);
            const reason = document.getElementById('banReason').value.trim();
            
            if (!userId || !serverId || !duration || !reason) {
                alert('Please fill all fields');
                return;
            }
            
            try {
                const response = await fetch('/api/bans/temp', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({userId, serverId, duration, reason})
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('User banned successfully!');
                    document.getElementById('banUserId').value = '';
                    document.getElementById('banServerSelect').value = '';
                    document.getElementById('banDuration').value = '';
                    document.getElementById('banReason').value = '';
                } else {
                    alert('Ban failed');
                }
            } catch (error) {
                alert('Ban error: ' + error.message);
            }
        }
        
        async function giveItem() {
            const playerId = document.getElementById('givePlayerId').value.trim();
            const serverId = document.getElementById('giveItemServerSelect').value.trim();
            const item = document.getElementById('giveItem').value.trim();
            const amount = parseInt(document.getElementById('giveAmount').value);
            
            if (!playerId || !serverId || !item || !amount) {
                alert('Please fill all fields');
                return;
            }
            
            try {
                const response = await fetch('/api/items/give', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({playerId, serverId, item, amount})
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('Item given successfully!');
                    document.getElementById('givePlayerId').value = '';
                    document.getElementById('giveItemServerSelect').value = '';
                    document.getElementById('giveItem').value = '';
                    document.getElementById('giveAmount').value = '';
                } else {
                    alert('Give item failed');
                }
            } catch (error) {
                alert('Give item error: ' + error.message);
            }
        }
        
        // Token Management
        async function refreshToken() {
            const refreshBtn = document.getElementById('refreshTokenBtn');
            if (!refreshBtn) return;
            
            refreshBtn.textContent = 'Refreshing...';
            refreshBtn.disabled = true;
            
            try {
                const response = await fetch('/api/token/refresh', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('Token refreshed successfully!');
                    updateSystemStatus(); // Reload status
                } else {
                    alert('Token refresh failed. Please re-login with G-Portal credentials.');
                }
            } catch (error) {
                alert('Refresh error: ' + error.message);
            } finally {
                refreshBtn.textContent = 'Refresh Token';
                refreshBtn.disabled = false;
            }
        }
        
        // Make test function available globally
        window.testLiveConsole = testLiveConsole;
        
        // Initialize
        loadDashboard();
        // ===================================================================
        // SERVER LOADING FIX - PREVENTION STRATEGY
        // ===================================================================
        // Auto-fix server loading on page load to prevent User Management issues
        
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                if (!window.managedServers || window.managedServers.length === 0) {
                    console.log('🔄 Auto-fixing server loading for User Management...');
                    loadManagedServers();
                }
            }, 2000);
        });
        
        // Additional fix for tab switching
        document.addEventListener('tabChanged', function(e) {
            if (e.detail && e.detail.tabId === 'user-management') {
                if (!window.managedServers || window.managedServers.length === 0) {
                    console.log('🔄 Loading servers for User Management tab...');
                    loadManagedServers();
                }
            }
        });
        
        console.log('✅ GUST Server Loading Fix Applied - User Management server selection will work correctly');
</script>
