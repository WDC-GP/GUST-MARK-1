/**
 * Status Indicator Widget
 * Displays status badges and indicators with animations and tooltips
 */
class StatusIndicator extends BaseComponent{constructor(containerId,options ={}){super(containerId,options);this.animationFrame = null;this.pulseInterval = null;}get defaultOptions(){return{...super.defaultOptions,status: 'unknown',showText: true,showIcon: true,animate: true,size: 'medium',variant: 'default',clickable: false,tooltip: true,pulseOnChange: true,customStates:{}};}getInitialState(){return{...super.getInitialState(),status: this.options.status,previousStatus: null,isAnimating: false,lastUpdate: Date.now()};}render(){const{status}= this.state;const{showText,showIcon,size,variant,clickable,tooltip}= this.options;const statusInfo = this.getStatusInfo(status);const sizeClass = `status-indicator--${size}`;const variantClass = `status-indicator--${variant}`;const clickableClass = clickable ? 'status-indicator--clickable' : '';const animatingClass = this.state.isAnimating ? 'status-indicator--animating' : '';this.container.innerHTML = `
 <div class="status-indicator ${sizeClass}${variantClass}${clickableClass}${animatingClass}"
 data-status="${status}"
 ${tooltip ? `title="${statusInfo.tooltip}"` : ''}>
 ${showIcon ? `
 <div class="status-indicator__icon-container">
 <div class="status-indicator__icon ${statusInfo.colorClass}">
 ${statusInfo.icon}</div>
 ${this.options.animate ? `
 <div class="status-indicator__pulse ${statusInfo.colorClass}"></div>
 ` : ''}</div>
 ` : ''}${showText ? `
 <span class="status-indicator__text ${statusInfo.colorClass}">
 ${statusInfo.text}</span>
 ` : ''}${this.shouldShowBadge() ? `
 <div class="status-indicator__badge">
 ${this.getBadgeContent()}</div>
 ` : ''}${this.options.animate ? `
 <div class="status-indicator__loading ${this.state.isAnimating ? 'active' : ''}">
 <div class="loading-spinner"></div>
 </div>
 ` : ''}</div>
 `;if(this.options.animate && this.state.isAnimating){this.startAnimation();}}bindEvents(){if(this.options.clickable){this.addEventListener(this.container,'click',() =>{this.handleClick();});}this.addEventListener(this.container,'mouseenter',() =>{this.handleHover(true);});this.addEventListener(this.container,'mouseleave',() =>{this.handleHover(false);});}getStatusInfo(status){const customState = this.options.customStates[status];if(customState){return{...customState,colorClass: customState.colorClass || this.getDefaultColorClass(status)};}const statusMap ={online:{icon: this.getStatusIcon('online'),text: 'Online',colorClass: 'status-success',tooltip: 'Server is online and responsive',description: 'All systems operational'},offline:{icon: this.getStatusIcon('offline'),text: 'Offline',colorClass: 'status-error',tooltip: 'Server is offline or unreachable',description: 'Server connection failed'},loading:{icon: this.getStatusIcon('loading'),text: 'Loading',colorClass: 'status-loading',tooltip: 'Checking server status...',description: 'Status check in progress'},warning:{icon: this.getStatusIcon('warning'),text: 'Warning',colorClass: 'status-warning',tooltip: 'Server has warnings or issues',description: 'Attention required'},error:{icon: this.getStatusIcon('error'),text: 'Error',colorClass: 'status-error',tooltip: 'Server has errors',description: 'Critical issues detected'},maintenance:{icon: this.getStatusIcon('maintenance'),text: 'Maintenance',colorClass: 'status-maintenance',tooltip: 'Server is under maintenance',description: 'Scheduled maintenance in progress'},unknown:{icon: this.getStatusIcon('unknown'),text: 'Unknown',colorClass: 'status-unknown',tooltip: 'Server status is unknown',description: 'Status could not be determined'},connected:{icon: this.getStatusIcon('connected'),text: 'Connected',colorClass: 'status-connected',tooltip: 'Live connection established',description: 'Real-time monitoring active'},disconnected:{icon: this.getStatusIcon('disconnected'),text: 'Disconnected',colorClass: 'status-disconnected',tooltip: 'Live connection lost',description: 'Real-time monitoring inactive'},pending:{icon: this.getStatusIcon('pending'),text: 'Pending',colorClass: 'status-pending',tooltip: 'Operation pending',description: 'Waiting for response'},success:{icon: this.getStatusIcon('success'),text: 'Success',colorClass: 'status-success',tooltip: 'Operation completed successfully',description: 'All good!'}};return statusMap[status] || statusMap.unknown;}getStatusIcon(status){const iconMap ={online: '<i class="icon-check-circle"></i>',offline: '<i class="icon-x-circle"></i>',loading: '<i class="icon-loader"></i>',warning: '<i class="icon-alert-triangle"></i>',error: '<i class="icon-alert-circle"></i>',maintenance: '<i class="icon-tool"></i>',unknown: '<i class="icon-help-circle"></i>',connected: '<i class="icon-wifi"></i>',disconnected: '<i class="icon-wifi-off"></i>',pending: '<i class="icon-clock"></i>',success: '<i class="icon-check"></i>'};return iconMap[status] || iconMap.unknown;}getDefaultColorClass(status){const colorMap ={online: 'status-success',connected: 'status-success',success: 'status-success',offline: 'status-error',disconnected: 'status-error',error: 'status-error',warning: 'status-warning',maintenance: 'status-warning',loading: 'status-loading',pending: 'status-loading',unknown: 'status-unknown'};return colorMap[status] || 'status-unknown';}updateStatus(newStatus,options ={}){const previousStatus = this.state.status;if(previousStatus === newStatus && !options.force){return;}this.setState({previousStatus,status: newStatus,lastUpdate: Date.now()});if(this.options.pulseOnChange && this.options.animate){this.triggerPulse();}this.render();this.emit('statusChanged',{previous: previousStatus,current: newStatus,timestamp: this.state.lastUpdate});if(options.duration){setTimeout(() =>{if(this.state.status === newStatus){this.updateStatus(options.revertTo || 'unknown');}},options.duration);}}setLoading(loading = true){if(loading){this.setState({isAnimating: true,previousStatus: this.state.status});this.updateStatus('loading');}else{this.setState({isAnimating: false});if(this.state.previousStatus){this.updateStatus(this.state.previousStatus);}}}triggerPulse(){const indicator = this.container.querySelector('.status-indicator');if(!indicator) return;if(this.pulseInterval){clearTimeout(this.pulseInterval);}indicator.classList.add('status-indicator--pulse');this.pulseInterval = setTimeout(() =>{indicator.classList.remove('status-indicator--pulse');},600);}startAnimation(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame);}const animate = () =>{const loader = this.container.querySelector('.status-indicator__loading');if(loader && this.state.isAnimating){const rotation = (Date.now() / 10) % 360;const spinner = loader.querySelector('.loading-spinner');if(spinner){spinner.style.transform = `rotate(${rotation}deg)`;}this.animationFrame = requestAnimationFrame(animate);}};if(this.state.isAnimating){animate();}}shouldShowBadge(){return this.options.showBadge && this.getBadgeContent();}getBadgeContent(){if(this.options.badgeContent){return this.options.badgeContent;}if(this.state.status === 'connected' && this.options.connectionCount){return this.options.connectionCount;}return null;}handleClick(){if(!this.options.clickable) return;this.emit('click',{status: this.state.status,timestamp: Date.now()});const indicator = this.container.querySelector('.status-indicator');if(indicator){indicator.classList.add('status-indicator--clicked');setTimeout(() =>{indicator.classList.remove('status-indicator--clicked');},200);}}handleHover(isHovering){const indicator = this.container.querySelector('.status-indicator');if(!indicator) return;indicator.classList.toggle('status-indicator--hover',isHovering);this.emit('hover',{hovering: isHovering,status: this.state.status});}static createServerStatus(containerId,status = 'unknown',options ={}){return new StatusIndicator(containerId,{status,showText: true,showIcon: true,animate: true,tooltip: true,...options});}static createConnectionStatus(containerId,connected = false,options ={}){return new StatusIndicator(containerId,{status: connected ? 'connected' : 'disconnected',showText: true,showIcon: true,animate: true,tooltip: true,variant: 'dot',...options});}static createLoadingIndicator(containerId,options ={}){return new StatusIndicator(containerId,{status: 'loading',showText: false,showIcon: true,animate: true,size: 'small',variant: 'dot',...options});}static createCustomStatus(containerId,status,customConfig,options ={}){const customStates ={};customStates[status] = customConfig;return new StatusIndicator(containerId,{status,customStates,...options});}isOnline(){return this.state.status === 'online';}isOffline(){return this.state.status === 'offline';}isLoading(){return this.state.status === 'loading' || this.state.isAnimating;}hasError(){return ['error','offline'].includes(this.state.status);}hasWarning(){return ['warning','maintenance'].includes(this.state.status);}getStatusAge(){return Date.now() - this.state.lastUpdate;}getStatusAgeFormatted(){const age = this.getStatusAge();const seconds = Math.floor(age / 1000);const minutes = Math.floor(seconds / 60);const hours = Math.floor(minutes / 60);if(hours > 0) return `${hours}h ago`;if(minutes > 0) return `${minutes}m ago`;return `${seconds}s ago`;}flash(duration = 1000){const indicator = this.container.querySelector('.status-indicator');if(!indicator) return;indicator.classList.add('status-indicator--flash');setTimeout(() =>{indicator.classList.remove('status-indicator--flash');},duration);}bounce(){const indicator = this.container.querySelector('.status-indicator');if(!indicator) return;indicator.classList.add('status-indicator--bounce');setTimeout(() =>{indicator.classList.remove('status-indicator--bounce');},500);}shake(){const indicator = this.container.querySelector('.status-indicator');if(!indicator) return;indicator.classList.add('status-indicator--shake');setTimeout(() =>{indicator.classList.remove('status-indicator--shake');},500);}emit(eventName,data){if(this.options.eventBus){this.options.eventBus.emit(`status-indicator:${eventName}`,{component: this,...data});}const event = new CustomEvent(`statusIndicator:${eventName}`,{detail: data,bubbles: true});this.container.dispatchEvent(event);}onDestroy(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame);}if(this.pulseInterval){clearTimeout(this.pulseInterval);}}}