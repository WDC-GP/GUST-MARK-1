<!-- ============================================================================
     GUST Bot Enhanced - logs JavaScript Module (COMPLETE WORKING VERSION)
     ============================================================================
     Generated: 2025-06-19 (COMPLETE VERSION - ALL FUNCTIONS INCLUDED)
     
     Module for logs specific functionality + SIMPLE Auto Commands
     
     FEATURES:
     - ‚úÖ Log Management Functions (downloadLogs, refreshLogs, etc.) - ADDED
     - ‚úÖ Server dropdown population - ADDED  
     - ‚úÖ Log preview and file download - FIXED
     - ‚úÖ Original logs functions (preserved)
     - ‚úÖ Logs-based player count integration 
     - ‚úÖ SIMPLE auto commands using existing sendConsoleCommand()
     - ‚úÖ Actually sends "serverinfo" every 10 seconds
     - ‚úÖ Direct integration with your existing console system
     - ‚úÖ FIXED: Clean function exposure and proper initialization
     
     FLOW: Log Management + Player Count + Auto Commands + Server Selection
     ============================================================================ -->

<script>
    // ============================================================================
    // LOGS MODULE - LOG MANAGEMENT FUNCTIONS (ADDED)
    // ============================================================================
    
    // Global logs state
    let logsData = {
        logs: [],
        currentServer: null,
        loading: false,
        lastRefresh: null
    };
    
    function loadLogs() {
        console.log('üìã Loading Logs...');
        if (typeof initializeLogs === 'function') {
            initializeLogs();
        }
        
        // Load initial logs data
        loadLogsData();
    }

    function showLogsTab() {
        console.log('üìã Switching to logs tab...');
        
        if (typeof showTab === 'function') {
            showTab('logs');
        } else {
            // Fallback navigation
            document.querySelectorAll('.view').forEach(view => {
                if (view && view.classList) {
                    view.classList.add('hidden');
                }
            });
            
            document.querySelectorAll('.nav-tab').forEach(tab => {
                if (tab && tab.classList) {
                    tab.classList.remove('active');
                }
            });
            
            const logsView = document.getElementById('logs-view');
            const logsTab = document.getElementById('logs-tab');
            
            if (logsView) {
                logsView.classList.remove('hidden');
                console.log('‚úÖ Logs view shown');
            }
            
            if (logsTab) {
                logsTab.classList.add('active');
                console.log('‚úÖ Logs tab activated');
            }
        }
        
        setTimeout(() => {
            if (typeof initializeLogs === 'function') {
                initializeLogs();
            }
            loadLogs();
        }, 100);
    }
    
    function initializeLogs() {
        console.log('üîß Initializing Logs functionality...');
        
        // Populate server dropdown - ADDED
        populateServerDropdown();
        
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            statusDiv.innerHTML = `
                <div class="text-green-400 text-sm">
                    ‚úÖ Logs module initialized and ready (with auto commands)
                </div>
            `;
            statusDiv.classList.remove('hidden');
        }
        
        // Start automatic command system after initialization
        setTimeout(() => {
            startAutoConsoleCommands();
        }, 3000);
        
        console.log('‚úÖ Logs initialization complete');
    }
    
    // ============================================================================
    // LOG MANAGEMENT FUNCTIONS (ADDED - THESE WERE MISSING)
    // ============================================================================
    
    /**
     * Download logs for selected server
     */
    async function downloadLogs() {
        const serverSelect = document.getElementById('server-select');
        const downloadBtn = document.getElementById('download-logs-btn');
        
        if (!serverSelect || !serverSelect.value) {
            showLogsStatus('Please select a server first', 'warning');
            return;
        }
        
        const serverId = serverSelect.value;
        
        try {
            // Update UI
            if (downloadBtn) {
                downloadBtn.disabled = true;
                downloadBtn.textContent = '‚è≥ Downloading...';
            }
            
            showLogsStatus('Downloading logs from server...', 'info');
            
            // Call API
            const response = await fetch('/api/logs/download', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    server_id: serverId
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                showLogsStatus(`‚úÖ Downloaded ${result.entries_count || 0} log entries`, 'success');
                
                // Refresh logs list
                await loadLogsData();
                
            } else {
                showLogsStatus(`‚ùå Download failed: ${result.error}`, 'error');
            }
            
        } catch (error) {
            console.error('‚ùå Error downloading logs:', error);
            showLogsStatus(`‚ùå Download error: ${error.message}`, 'error');
            
        } finally {
            // Reset UI
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'üì• Download Logs';
            }
        }
    }
    
    /**
     * Refresh logs list
     */
    async function refreshLogs() {
        const refreshBtn = document.getElementById('refresh-logs-btn');
        
        try {
            // Update UI
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.textContent = '‚è≥ Refreshing...';
            }
            
            showLogsStatus('Refreshing logs list...', 'info');
            
            // Call API
            await loadLogsData();
            
            showLogsStatus('‚úÖ Logs list refreshed', 'success');
            
        } catch (error) {
            console.error('‚ùå Error refreshing logs:', error);
            showLogsStatus(`‚ùå Refresh error: ${error.message}`, 'error');
            
        } finally {
            // Reset UI
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'üîÑ Refresh';
            }
        }
    }
    
    /**
     * Load logs data from API
     */
    async function loadLogsData() {
        try {
            logsData.loading = true;
            
            const response = await fetch('/api/logs');
            const result = await response.json();
            
            if (response.ok) {
                logsData.logs = result.logs || [];
                logsData.lastRefresh = new Date();
                
                // Update display
                updateLogsDisplay();
                
            } else {
                console.error('‚ùå Error loading logs:', result.error);
                showLogsStatus(`‚ùå Failed to load logs: ${result.error}`, 'error');
            }
            
        } catch (error) {
            console.error('‚ùå Error loading logs data:', error);
            showLogsStatus(`‚ùå Error loading logs: ${error.message}`, 'error');
            
        } finally {
            logsData.loading = false;
        }
    }
    
    /**
     * Update logs display
     */
    function updateLogsDisplay() {
        const logsList = document.getElementById('logs-list');
        if (!logsList) return;
        
        if (logsData.logs.length === 0) {
            logsList.innerHTML = `
                <div class="text-gray-400 text-center py-8">
                    <div class="text-4xl mb-4">üìã</div>
                    <div>No logs downloaded yet</div>
                    <div class="text-sm mt-2">Click "Download Logs" to fetch server logs</div>
                </div>
            `;
            return;
        }
        
        logsList.innerHTML = logsData.logs.map(log => `
            <div class="bg-gray-700 p-4 rounded-lg border border-gray-600 mb-4">
                <div class="flex items-center justify-between">
                    <div class="flex-1">
                        <div class="flex items-center space-x-2">
                            <h4 class="font-semibold text-lg text-cyan-400">üìã ${log.server_id}</h4>
                            <span class="text-xs bg-blue-900 text-blue-300 px-2 py-1 rounded">
                                ${log.entries_count || 0} entries
                            </span>
                        </div>
                        <div class="text-sm text-gray-300 mt-1">
                            Downloaded: ${new Date(log.timestamp).toLocaleString()}
                        </div>
                        <div class="text-xs text-gray-400">
                            Region: ${log.region || 'Unknown'} | ID: ${log.id}
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                        <button onclick="previewLog('${log.id}')" 
                                class="bg-cyan-600 hover:bg-cyan-700 px-3 py-1 rounded text-xs" 
                                title="Preview Log">
                            üëÅÔ∏è Preview
                        </button>
                        <button onclick="downloadLogFile('${log.id}')" 
                                class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-xs" 
                                title="Download File">
                            üíæ Download
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    /**
     * Preview log entries (FIXED - uses existing data instead of missing API endpoint)
     */
    function previewLog(logId) {
        try {
            // Find the log in our existing data
            const logEntry = logsData.logs.find(log => log.id === logId);
            
            if (!logEntry) {
                showLogsStatus(`‚ùå Log not found: ${logId}`, 'error');
                return;
            }
            
            // Use recent_entries if available, otherwise show basic info
            if (logEntry.recent_entries && logEntry.recent_entries.length > 0) {
                showLogPreview(logEntry.recent_entries);
                showLogsStatus(`‚úÖ Showing ${logEntry.recent_entries.length} recent entries from log`, 'success');
            } else {
                // Show basic log info if no entries available
                const basicInfo = [{
                    timestamp: logEntry.timestamp,
                    level: 'INFO',
                    message: `Log file contains ${logEntry.entries_count || 0} total entries. Download the full file to view all entries.`,
                    raw: `Server: ${logEntry.server_id} | Region: ${logEntry.region || 'Unknown'} | Downloaded: ${new Date(logEntry.timestamp).toLocaleString()}`
                }];
                showLogPreview(basicInfo);
                showLogsStatus(`‚ÑπÔ∏è Preview shows basic info. Download the full log file to view all ${logEntry.entries_count || 0} entries.`, 'info');
            }
            
        } catch (error) {
            console.error('‚ùå Error previewing log:', error);
            showLogsStatus(`‚ùå Preview error: ${error.message}`, 'error');
        }
    }
    
    /**
     * Download log file
     */
    function downloadLogFile(logId) {
        const downloadUrl = `/api/logs/${logId}/download`;
        
        // Create temporary download link
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = `log_${logId}.json`;
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showLogsStatus('‚úÖ Download started', 'success');
    }
    
    /**
     * Show log preview
     */
    function showLogPreview(entries) {
        const previewContainer = document.getElementById('log-preview-container');
        const previewDiv = document.getElementById('log-preview');
        
        if (!previewContainer || !previewDiv) return;
        
        previewDiv.innerHTML = entries.map(entry => `
            <div class="border-b border-gray-700 pb-2 mb-2">
                <div class="flex items-center justify-between text-xs">
                    <span class="text-blue-400">${entry.timestamp || 'Unknown time'}</span>
                    <span class="text-purple-400">${entry.level || 'INFO'}</span>
                </div>
                <div class="text-gray-300 mt-1 font-mono text-sm">
                    ${escapeHtml(entry.message || entry.raw || 'No message')}
                </div>
            </div>
        `).join('');
        
        previewContainer.classList.remove('hidden');
    }
    
    /**
     * Hide log preview
     */
    function hideLogPreview() {
        const previewContainer = document.getElementById('log-preview-container');
        if (previewContainer) {
            previewContainer.classList.add('hidden');
        }
    }
    
    /**
     * Populate server dropdown (FIXED - THIS WAS MISSING)
     */
    function populateServerDropdown() {
        const serverSelect = document.getElementById('server-select');
        if (!serverSelect) {
            console.warn('‚ö†Ô∏è Server select dropdown not found');
            return;
        }
        
        // Check if managedServers is available
        if (typeof managedServers !== 'undefined' && managedServers && managedServers.length > 0) {
            console.log(`‚úÖ Logs: Found ${managedServers.length} managed servers`);
            
            // Clear loading message
            serverSelect.innerHTML = '<option value="">Select a server...</option>';
            
            // Add servers to dropdown
            managedServers.forEach(server => {
                if (server.isActive) {
                    const option = document.createElement('option');
                    option.value = server.serverId;
                    option.textContent = `${server.serverName} (${server.serverId})`;
                    serverSelect.appendChild(option);
                }
            });
            
        } else {
            console.log('‚è≥ Logs: managedServers not ready yet, will retry...');
            
            // Wait for servers to be available
            let attempts = 0;
            const maxAttempts = 20;
            
            const serverWatcher = setInterval(() => {
                attempts++;
                console.log(`üîç Logs: Attempt ${attempts}/${maxAttempts}: Checking for servers...`);
                
                if (typeof managedServers !== 'undefined' && managedServers && managedServers.length > 0) {
                    console.log('‚úÖ Logs: Servers found and populating!');
                    populateServerDropdown(); // Recursive call
                    clearInterval(serverWatcher);
                } else if (attempts >= maxAttempts) {
                    console.warn('‚ö†Ô∏è Logs: Timeout waiting for servers');
                    serverSelect.innerHTML = '<option value="">No servers found - Try refreshing</option>';
                    clearInterval(serverWatcher);
                }
            }, 500);
        }
    }
    
    // ============================================================================
    // UTILITY FUNCTIONS (ADDED)
    // ============================================================================
    
    function escapeHtml(text) {
        if (!text) return '';
        if (typeof text !== 'string') return String(text);
        
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function showLogsStatus(message, type = 'info') {
        console.log(`üìã Logs Status [${type.toUpperCase()}]: ${message}`);
        
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            const iconMap = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'warning': '‚ö†Ô∏è',
                'error': '‚ùå'
            };
            
            const colorMap = {
                'info': 'text-blue-400',
                'success': 'text-green-400',
                'warning': 'text-yellow-400',
                'error': 'text-red-400'
            };
            
            statusDiv.innerHTML = `
                <div class="${colorMap[type] || 'text-gray-400'} text-sm">
                    ${iconMap[type] || '‚ÑπÔ∏è'} ${message}
                </div>
            `;
            statusDiv.classList.remove('hidden');
            
            // Auto-hide after 5 seconds for success/info messages
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    hideLogsStatus();
                }, 5000);
            }
        }
    }
    
    function hideLogsStatus() {
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            statusDiv.classList.add('hidden');
        }
    }

    // ============================================================================
    // LOGS-BASED PLAYER COUNT FUNCTIONS (EXISTING - PRESERVED)
    // ============================================================================

    /**
     * Get player count from logs for a specific server (MAIN FUNCTION)
     */
    async function getPlayerCountFromLogs(serverId) {
        try {
            console.log(`üìä Getting player count from logs for server ${serverId}...`);
            
            if (!serverId) {
                throw new Error('Server ID is required');
            }
            
            const response = await fetch(`/api/logs/player-count/${serverId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const result = await response.json();
            
            if (result.success && result.data) {
                console.log(`‚úÖ Got player count from logs: ${result.data.current}/${result.data.max} (${result.data.percentage}%)`);
                
                if (typeof window.updatePlayerCountDisplay === 'function') {
                    window.updatePlayerCountDisplay(serverId, result.data, 'success');
                }
                
                return {
                    success: true,
                    data: result.data,
                    source: 'logs_api'
                };
            } else {
                console.warn(`‚ö†Ô∏è Logs API returned no data for ${serverId}: ${result.error || 'Unknown error'}`);
                
                if (typeof window.updatePlayerCountDisplay === 'function') {
                    window.updatePlayerCountDisplay(serverId, null, 'error');
                }
                
                return {
                    success: false,
                    error: result.error || 'No player count data available',
                    source: 'logs_api'
                };
            }
            
        } catch (error) {
            console.error(`‚ùå Error getting player count from logs for ${serverId}:`, error);
            
            if (typeof window.updatePlayerCountDisplay === 'function') {
                window.updatePlayerCountDisplay(serverId, null, 'error');
            }
            
            return {
                success: false,
                error: error.message,
                source: 'logs_api'
            };
        }
    }

    /**
     * Force refresh with command + logs
     */
    async function forceRefreshPlayerCountFromLogs(serverId) {
        try {
            console.log(`üîÑ Force refresh for ${serverId}...`);
            
            // Send command first
            await sendSingleAutoCommand(serverId, 'serverinfo');
            
            // Wait and get fresh logs
            setTimeout(async () => {
                await getPlayerCountFromLogs(serverId);
            }, 4000);
            
        } catch (error) {
            console.error(`‚ùå Force refresh failed for ${serverId}:`, error);
        }
    }

    // ============================================================================
    // SIMPLE AUTO CONSOLE COMMAND SYSTEM - USES EXISTING CONSOLE (EXISTING - PRESERVED)
    // ============================================================================
    
    // Configuration
    const autoConsoleConfig = {
        enabled: true,
        interval: 10000,           // 10 seconds between commands
        commandsToSend: ['serverinfo'], // Commands to send automatically
        rotateServers: true,       // Rotate through servers
        maxServersPerRound: 1,     // How many servers per round
        debug: true                // Enable debug logging
    };
    
    // State tracking
    const autoConsoleState = {
        running: false,
        intervalId: null,
        monitorInterval: null,  // For player count monitoring
        currentServerIndex: 0,
        totalCommandsSent: 0,
        lastCommandTime: null,
        errors: 0,
        activeCommands: new Map(),  // Track active commands
        lastCommandTimes: new Map() // Track last command time per server
    };
    
    /**
     * Start automatic console command sending
     */
    function startAutoConsoleCommands() {
        if (autoConsoleState.running) {
            console.log('‚ö†Ô∏è Auto console commands already running');
            return;
        }
        
        console.log('üöÄ Starting automatic console commands...');
        console.log(`üì° Will send commands every ${autoConsoleConfig.interval/1000} seconds`);
        
        autoConsoleState.running = true;
        
        // Send first command after short delay
        setTimeout(() => {
            sendAutomaticConsoleCommand();
        }, 2000);
        
        // Set up interval for regular commands
        autoConsoleState.intervalId = setInterval(() => {
            sendAutomaticConsoleCommand();
        }, autoConsoleConfig.interval);
        
        console.log('‚úÖ Auto console commands started');
        updateAutoCommandStatus('‚ñ∂Ô∏è Running');
    }
    
    /**
     * Stop automatic console command sending
     */
    function stopAutoConsoleCommands() {
        if (!autoConsoleState.running) {
            return;
        }
        
        console.log('‚èπÔ∏è Stopping automatic console commands...');
        
        autoConsoleState.running = false;
        
        if (autoConsoleState.intervalId) {
            clearInterval(autoConsoleState.intervalId);
            autoConsoleState.intervalId = null;
        }
        
        console.log('‚úÖ Auto console commands stopped');
        updateAutoCommandStatus('‚è∏Ô∏è Stopped');
    }
    
    /**
     * Send automatic console command using existing console system
     */
    async function sendAutomaticConsoleCommand() {
        try {
            if (!autoConsoleConfig.enabled || !autoConsoleState.running) {
                return;
            }
            
            // Get available servers
            const servers = getAvailableServersForAutoCommands();
            if (servers.length === 0) {
                if (autoConsoleConfig.debug) {
                    console.log('üìä No servers available for auto commands');
                }
                return;
            }
            
            // Get server(s) to send commands to
            const targetServers = getTargetServersForCommands(servers);
            
            for (const server of targetServers) {
                for (const command of autoConsoleConfig.commandsToSend) {
                    await sendSingleAutoCommand(server.id, command);
                    
                    // Small delay between commands
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            autoConsoleState.lastCommandTime = new Date().toISOString();
            
            if (autoConsoleConfig.debug) {
                console.log(`üìä Auto commands complete. Total sent: ${autoConsoleState.totalCommandsSent}`);
            }
            
        } catch (error) {
            console.error('‚ùå Error in automatic console command:', error);
            autoConsoleState.errors++;
        }
    }
    
    /**
     * Send a single automatic command using existing console system
     */
    async function sendSingleAutoCommand(serverId, command) {
        try {
            if (autoConsoleConfig.debug) {
                console.log(`üì° Auto-sending "${command}" to server ${serverId}...`);
            }
            
            // Check if command is already active for this server
            if (autoConsoleState.activeCommands.has(serverId)) {
                console.log(`‚è≥ Command already active for ${serverId}, skipping`);
                return;
            }
            
            // Mark command as active
            autoConsoleState.activeCommands.set(serverId, {
                command: command,
                startTime: Date.now(),
                status: 'sending'
            });
            
            // Set up the console for this server and command
            const consoleServerSelect = document.getElementById('consoleServerSelect');
            const consoleInput = document.getElementById('consoleInput');
            
            if (!consoleServerSelect || !consoleInput) {
                console.error('‚ùå Console elements not found');
                autoConsoleState.activeCommands.delete(serverId);
                return;
            }
            
            // Save current values
            const originalServer = consoleServerSelect.value;
            const originalCommand = consoleInput.value;
            
            // Set server and command
            consoleServerSelect.value = serverId;
            consoleInput.value = command;
            
            // Update display to show loading (but preserve old values)
            if (typeof window.updatePlayerCountDisplay === 'function') {
                window.updatePlayerCountDisplay(serverId, null, 'loading');
            }
            
            // Check if sendConsoleCommand function exists and use it
            if (typeof window.sendConsoleCommand === 'function') {
                await window.sendConsoleCommand();
                
                autoConsoleState.totalCommandsSent++;
                autoConsoleState.lastCommandTimes.set(serverId, Date.now());
                
                // Update command status
                const commandInfo = autoConsoleState.activeCommands.get(serverId);
                if (commandInfo) {
                    commandInfo.status = 'sent';
                    commandInfo.sentTime = Date.now();
                }
                
                if (autoConsoleConfig.debug) {
                    console.log(`‚úÖ Auto command "${command}" sent to ${serverId}`);
                }
                
                // Trigger logs-based update after command
                setTimeout(async () => {
                    try {
                        await getPlayerCountFromLogs(serverId);
                        
                        // Mark command as complete
                        const cmdInfo = autoConsoleState.activeCommands.get(serverId);
                        if (cmdInfo) {
                            cmdInfo.status = 'completed';
                            cmdInfo.completedTime = Date.now();
                            
                            // Remove from active commands after a short delay
                            setTimeout(() => {
                                autoConsoleState.activeCommands.delete(serverId);
                            }, 2000);
                        }
                    } catch (error) {
                        console.error(`‚ùå Error in logs update for ${serverId}:`, error);
                        autoConsoleState.activeCommands.delete(serverId);
                        
                        // Update display to show error (but preserve old values)
                        if (typeof window.updatePlayerCountDisplay === 'function') {
                            window.updatePlayerCountDisplay(serverId, null, 'error');
                        }
                    }
                }, 4000); // Wait 4 seconds for command to execute and be logged
                
            } else {
                console.warn('‚ö†Ô∏è sendConsoleCommand function not available');
                autoConsoleState.activeCommands.delete(serverId);
                
                // Update display to show error (but preserve old values)
                if (typeof window.updatePlayerCountDisplay === 'function') {
                    window.updatePlayerCountDisplay(serverId, null, 'error');
                }
            }
            
            // Restore original values
            consoleServerSelect.value = originalServer;
            consoleInput.value = originalCommand;
            
        } catch (error) {
            console.error(`‚ùå Error sending auto command to ${serverId}:`, error);
            autoConsoleState.errors++;
            autoConsoleState.activeCommands.delete(serverId);
            
            // Update display to show error (but preserve old values)
            if (typeof window.updatePlayerCountDisplay === 'function') {
                window.updatePlayerCountDisplay(serverId, null, 'error');
            }
        }
    }
    
    /**
     * Get available servers for auto commands
     */
    function getAvailableServersForAutoCommands() {
        const servers = [];
        
        // Try to get from managedServers (main system)
        if (typeof window.managedServers !== 'undefined' && window.managedServers) {
            window.managedServers.forEach(server => {
                if (server && server.serverId && server.isActive !== false) {
                    servers.push({
                        id: server.serverId,
                        name: server.serverName || `Server ${server.serverId}`,
                        region: server.serverRegion || 'US'
                    });
                }
            });
        }
        
        // Fallback: try to get from console dropdown
        if (servers.length === 0) {
            const consoleSelect = document.getElementById('consoleServerSelect');
            if (consoleSelect) {
                Array.from(consoleSelect.options).forEach(option => {
                    if (option.value && option.value !== '') {
                        servers.push({
                            id: option.value,
                            name: option.textContent || `Server ${option.value}`,
                            region: 'US'
                        });
                    }
                });
            }
        }
        
        return servers;
    }
    
    /**
     * Get target servers for this command round
     */
    function getTargetServersForCommands(servers) {
        if (!autoConsoleConfig.rotateServers) {
            // Send to all servers (up to maxServersPerRound)
            return servers.slice(0, autoConsoleConfig.maxServersPerRound);
        }
        
        // Rotate through servers
        const targetServers = [];
        
        for (let i = 0; i < autoConsoleConfig.maxServersPerRound && servers.length > 0; i++) {
            const serverIndex = autoConsoleState.currentServerIndex % servers.length;
            targetServers.push(servers[serverIndex]);
            autoConsoleState.currentServerIndex++;
        }
        
        return targetServers;
    }
    
    /**
     * Update auto command status in UI (Enhanced)
     */
    function updateAutoCommandStatus(status) {
        // Try to find or create status element
        let statusElement = document.getElementById('auto-command-status');
        
        if (!statusElement) {
            // Try to add to logs status area
            const logsStatus = document.getElementById('logs-status');
            if (logsStatus) {
                const statusDiv = document.createElement('div');
                statusDiv.id = 'auto-command-status';
                statusDiv.className = 'text-sm mt-2 p-2 bg-gray-800 rounded border';
                logsStatus.appendChild(statusDiv);
                statusElement = statusDiv;
            }
        }
        
        if (statusElement) {
            const activeCount = autoConsoleState.activeCommands.size;
            const successRate = autoConsoleState.totalCommandsSent > 0 ? 
                ((autoConsoleState.totalCommandsSent - autoConsoleState.errors) / autoConsoleState.totalCommandsSent * 100).toFixed(1) : 
                '100';
                
            statusElement.innerHTML = `
                <div class="text-cyan-400 font-medium">ü§ñ Auto Console Commands</div>
                <div class="text-xs text-gray-300 mt-1">
                    Status: ${status} | 
                    Commands Sent: ${autoConsoleState.totalCommandsSent} | 
                    Errors: ${autoConsoleState.errors} |
                    Success Rate: ${successRate}%
                </div>
                <div class="text-xs text-gray-400 mt-1">
                    Active: ${activeCount} | 
                    Interval: ${autoConsoleConfig.interval/1000}s | 
                    Last: ${autoConsoleState.lastCommandTime ? new Date(autoConsoleState.lastCommandTime).toLocaleTimeString() : 'Never'}
                </div>
            `;
        }
    }
    
    /**
     * Test the auto command system
     */
    function testAutoConsoleCommands() {
        console.log('üß™ Testing auto console command system...');
        
        const servers = getAvailableServersForAutoCommands();
        console.log(`üìä Found ${servers.length} servers:`, servers);
        
        if (servers.length > 0) {
            console.log('üéØ Testing with first server...');
            sendSingleAutoCommand(servers[0].id, 'serverinfo');
        } else {
            console.log('‚ùå No servers available for testing');
        }
    }
    
    /**
     * Get enhanced auto command system status
     */
    function getAutoConsoleStatus() {
        const activeServers = getAvailableServersForAutoCommands();
        
        return {
            running: autoConsoleState.running,
            config: autoConsoleConfig,
            state: {
                ...autoConsoleState,
                activeCommands: autoConsoleState.activeCommands.size,
                activeCommandsList: Array.from(autoConsoleState.activeCommands.entries()).map(([serverId, cmdInfo]) => ({
                    serverId,
                    command: cmdInfo.command,
                    status: cmdInfo.status,
                    duration: Date.now() - cmdInfo.startTime
                }))
            },
            availableServers: activeServers.length,
            serverList: activeServers.map(s => ({ id: s.id, name: s.name }))
        };
    }
    
    /**
     * Toggle auto commands on/off
     */
    function toggleAutoConsoleCommands() {
        if (autoConsoleState.running) {
            stopAutoConsoleCommands();
        } else {
            startAutoConsoleCommands();
        }
        
        return autoConsoleState.running;
    }

    // ============================================================================
    // CLEAN FUNCTION EXPOSURE (FIXED - REPLACE ALL EXISTING EXPOSURES)
    // ============================================================================
    
    if (typeof window !== 'undefined') {
        // Core logs functions
        window.loadLogs = loadLogs;
        window.showLogsTab = showLogsTab;
        window.initializeLogs = initializeLogs;
        window.downloadLogs = downloadLogs;
        window.refreshLogs = refreshLogs;
        window.previewLog = previewLog;
        window.hideLogPreview = hideLogPreview;
        window.populateServerDropdown = populateServerDropdown;
        window.showLogsStatus = showLogsStatus;
        window.hideLogsStatus = hideLogsStatus;
        
        // Player count functions
        window.getPlayerCountFromLogs = getPlayerCountFromLogs;
        window.forceRefreshPlayerCountFromLogs = forceRefreshPlayerCountFromLogs;
        
        // Auto command functions
        window.startAutoConsoleCommands = startAutoConsoleCommands;
        window.stopAutoConsoleCommands = stopAutoConsoleCommands;
        window.testAutoConsoleCommands = testAutoConsoleCommands;
        window.getAutoConsoleStatus = getAutoConsoleStatus;
        window.toggleAutoConsoleCommands = toggleAutoConsoleCommands;
        window.sendSingleAutoCommand = sendSingleAutoCommand;
        
        console.log('‚úÖ All logs functions properly exposed to window');
    }
    
    // ============================================================================
    // MODULE INITIALIZATION (CLEAN - SINGLE EVENT LISTENER)
    // ============================================================================
    
    // Single DOM event listener
    document.addEventListener('DOMContentLoaded', function() {
        console.log('üìã Logs module ready and initialized');
        
        // Auto-initialize if on logs tab
        if (window.location.hash === '#logs') {
            setTimeout(initializeLogs, 100);
        }
        
        // Set up integration with tab system
        if (typeof window.tabInitializers === 'undefined') {
            window.tabInitializers = {};
        }
        window.tabInitializers.logs = initializeLogs;
        
        // Start auto commands after system is ready
        setTimeout(() => {
            if (autoConsoleConfig.enabled) {
                const servers = getAvailableServersForAutoCommands();
                if (servers.length > 0) {
                    console.log('üîß Auto-starting console command system...');
                    startAutoConsoleCommands();
                } else {
                    console.log('‚è≥ Waiting for servers to be available...');
                    
                    // Check for servers periodically
                    const serverCheck = setInterval(() => {
                        const availableServers = getAvailableServersForAutoCommands();
                        if (availableServers.length > 0) {
                            clearInterval(serverCheck);
                            console.log('üéØ Servers detected, starting auto console commands...');
                            startAutoConsoleCommands();
                        }
                    }, 3000);
                    
                    // Stop checking after 30 seconds
                    setTimeout(() => {
                        clearInterval(serverCheck);
                    }, 30000);
                }
            }
        }, 5000); // Wait 5 seconds for full system initialization
    });
    
    console.log('üöÄ Logs module FULLY LOADED with clean function exposure');
    console.log('üì° Auto commands will use existing sendConsoleCommand() every 10 seconds');
    
</script>