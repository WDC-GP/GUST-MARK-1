<script>
    // ============================================================================
    // LOGS MODULE (FINAL CONFLICT-PROTECTED VERSION)
    // ============================================================================
    
    console.log('📋 Loading Logs module with FINAL conflict protection...');
    
    function showLogsTab() {
        console.log('📋 Showing Logs tab...');
        
        // Hide other views
        const views = ['dashboard-view', 'server-manager-view', 'console-view', 'server-health', 'events-view', 'economy-view', 'gambling-view', 'clans-view', 'user-management-view'];
        views.forEach(viewId => {
            const view = document.getElementById(viewId);
            if (view) {
                view.style.display = 'none';
            }
        });
        
        // Show logs view
        const logsView = document.getElementById('logs-view');
        if (logsView) {
            logsView.style.display = 'block';
            
            // Activate tab
            const tabs = document.querySelectorAll('.tab-button');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            const logsTab = document.querySelector('[data-tab="logs"]');
            if (logsTab) {
                logsTab.classList.add('active');
            }
        }
        
        setTimeout(() => {
            if (typeof initializeLogs === 'function') {
                initializeLogs();
            }
            loadLogs();
            
            // Start final dropdown solution
            console.log('🎯 Starting FINAL dropdown solution...');
            startFinalDropdownSolution();
        }, 100);
    }
    
    function initializeLogs() {
        console.log('🔧 Initializing Logs functionality...');
        
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            statusDiv.innerHTML = `
                <div class="text-green-400 text-sm">
                    ✅ Logs module initialized (FINAL VERSION)
                </div>
            `;
            statusDiv.classList.remove('hidden');
        }
        
        // Start automatic command system
        setTimeout(() => {
            startAutoConsoleCommands();
        }, 3000);
        
        console.log('✅ Logs initialization complete');
    }
    
    function loadLogs() {
        console.log('📋 Loading logs...');
        setTimeout(() => {
            refreshLogs();
        }, 500);
    }
    
    // ============================================================================
    // ✅ FINAL DROPDOWN SOLUTION
    // ============================================================================
    
    function startFinalDropdownSolution() {
        console.log('🎯 Starting FINAL dropdown solution...');
        
        // Ultimate dropdown population that always works
        function ultimatePopulateDropdown() {
            const dropdown = document.getElementById('server-select');
            if (!dropdown) {
                console.warn('⚠️ Dropdown not found');
                return false;
            }
            
            if (!window.managedServers || window.managedServers.length === 0) {
                dropdown.innerHTML = '<option value="">Loading servers...</option>';
                return false;
            }
            
            console.log(`🎯 ULTIMATE population with ${window.managedServers.length} servers...`);
            
            // Clear and repopulate
            dropdown.innerHTML = '<option value="">Select a server...</option>';
            
            let added = 0;
            window.managedServers.forEach((server, index) => {
                if (server.serverId) {
                    const option = document.createElement('option');
                    option.value = server.serverId;
                    
                    // FINAL status detection - prioritize showing ONLINE
                    let status = 'UNKNOWN';
                    if (server.status && typeof server.status === 'string') {
                        const serverStatus = server.status.toLowerCase();
                        if (serverStatus === 'online' || serverStatus === 'active' || serverStatus === 'connected') {
                            status = 'ONLINE';
                        } else if (serverStatus === 'offline' || serverStatus === 'inactive') {
                            status = 'OFFLINE';
                        }
                    } else if (server.isActive === true) {
                        // If server is active, assume online
                        status = 'ONLINE';
                    } else if (server.isActive === false) {
                        status = 'OFFLINE';
                    }
                    
                    option.textContent = `${server.serverName} (${server.serverId}) [${status}]`;
                    
                    // Apply styling
                    if (status === 'ONLINE') {
                        option.style.color = '#10B981';
                        option.style.fontWeight = 'bold';
                    } else if (status === 'OFFLINE') {
                        option.style.color = '#F59E0B';
                    } else {
                        option.style.color = '#6B7280';
                    }
                    
                    dropdown.appendChild(option);
                    added++;
                    
                    console.log(`🎯 ULTIMATE ADD: ${server.serverName} [${status}]`);
                } else {
                    console.warn(`⚠️ Server ${index + 1} missing serverId:`, server);
                }
            });
            
            console.log(`🎯 ULTIMATE population complete: ${added} servers added`);
            
            if (typeof showLogsStatus === 'function') {
                showLogsStatus(`🎯 ${added} servers loaded (FINAL VERSION)`, 'success');
            }
            
            return true;
        }
        
        // Replace global functions
        window.populateServerDropdown = ultimatePopulateDropdown;
        window.forceRefreshServerDropdown = ultimatePopulateDropdown;
        
        // Immediate population
        ultimatePopulateDropdown();
        
        // FINAL monitoring - very aggressive (every 3 seconds)
        setInterval(() => {
            const dropdown = document.getElementById('server-select');
            if (!dropdown) return;
            
            const hasServers = window.managedServers && window.managedServers.length > 0;
            const expectedOptions = hasServers ? window.managedServers.length + 1 : 1;
            const actualOptions = dropdown.options.length;
            
            // If options don't match OR if any server shows UNKNOWN, re-populate
            const hasUnknown = Array.from(dropdown.options).some(opt => 
                opt.textContent.includes('[UNKNOWN]')
            );
            
            if ((hasServers && actualOptions !== expectedOptions) || hasUnknown) {
                console.log(`🚨 FINAL MONITOR: Fixing dropdown (expected: ${expectedOptions}, actual: ${actualOptions}, hasUnknown: ${hasUnknown})`);
                ultimatePopulateDropdown();
            }
        }, 3000); // Check every 3 seconds
        
        // Event listeners
        document.addEventListener('managedServersLoaded', () => {
            console.log('📡 managedServersLoaded - FINAL re-population');
            setTimeout(ultimatePopulateDropdown, 100);
        });
        
        // Multiple fallback attempts
        [1000, 3000, 5000, 10000, 15000].forEach(delay => {
            setTimeout(() => {
                const dropdown = document.getElementById('server-select');
                if (dropdown && window.managedServers?.length > 0) {
                    const hasUnknown = Array.from(dropdown.options).some(opt => 
                        opt.textContent.includes('[UNKNOWN]')
                    );
                    if (dropdown.options.length <= 1 || hasUnknown) {
                        console.log(`🔄 FINAL fallback (${delay}ms): Re-populating...`);
                        ultimatePopulateDropdown();
                    }
                }
            }, delay);
        });
        
        console.log('🎯 FINAL dropdown solution active');
    }
    
    // ============================================================================
    // LOG MANAGEMENT FUNCTIONS (UNCHANGED)
    // ============================================================================
    
    async function downloadLogs() {
        const serverSelect = document.getElementById('server-select');
        const downloadBtn = document.getElementById('download-logs-btn');
        
        if (!serverSelect || !serverSelect.value) {
            showLogsStatus('Please select a server first', 'warning');
            return;
        }
        
        const serverId = serverSelect.value;
        
        try {
            if (downloadBtn) {
                downloadBtn.disabled = true;
                downloadBtn.textContent = '⏳ Downloading...';
            }
            
            showLogsStatus('Downloading logs from server...', 'info');
            
            const response = await fetch('/api/logs/download', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'same-origin',
                body: JSON.stringify({
                    server_id: serverId
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success) {
                showLogsStatus(`✅ Downloaded ${result.entries_count || 0} log entries`, 'success');
                setTimeout(() => refreshLogs(), 1000);
            } else {
                throw new Error(result.error || 'Download failed');
            }
            
        } catch (error) {
            console.error('❌ Error downloading logs:', error);
            showLogsStatus(`❌ Download failed: ${error.message}`, 'error');
        } finally {
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.textContent = '📥 Download Logs';
            }
        }
    }
    
    async function refreshLogs() {
        console.log('🔄 Refreshing logs list...');
        
        const refreshBtn = document.getElementById('refresh-logs-btn');
        
        try {
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.textContent = '⏳ Refreshing...';
            }
            
            showLogsStatus('Refreshing logs list...', 'info');
            
            const response = await fetch('/api/logs', {
                method: 'GET',
                credentials: 'same-origin'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success) {
                displayLogsList(result.logs || []);
                showLogsStatus(`✅ Loaded ${result.logs?.length || 0} log files`, 'success');
            } else {
                throw new Error(result.error || 'Failed to load logs');
            }
            
        } catch (error) {
            console.error('❌ Error refreshing logs:', error);
            showLogsStatus(`❌ Refresh failed: ${error.message}`, 'error');
        } finally {
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.textContent = '🔄 Refresh';
            }
        }
    }
    
    function displayLogsList(logs) {
        const container = document.getElementById('logs-list');
        if (!container) return;
        
        if (!logs || logs.length === 0) {
            container.innerHTML = `
                <div class="text-gray-400 text-center py-8">
                    <div class="text-4xl mb-4">📋</div>
                    <div>No logs available</div>
                    <div class="text-sm mt-2">Download logs from your servers to see them here</div>
                </div>
            `;
            return;
        }
        
        const logsHTML = logs.map(log => `
            <div class="bg-gray-700 p-4 rounded-lg border border-gray-600">
                <div class="flex items-center justify-between">
                    <div class="flex-1">
                        <h4 class="font-semibold text-lg">${escapeHtml(log.server_name || 'Unknown Server')}</h4>
                        <p class="text-gray-400 text-sm">Server ID: ${escapeHtml(log.server_id || 'N/A')}</p>
                        <p class="text-gray-400 text-xs">Downloaded: ${new Date(log.timestamp || log.download_time).toLocaleString()}</p>
                        <p class="text-gray-400 text-xs">Entries: ${log.parsed_entries || log.entries_count || 0}</p>
                        ${log.file_size ? `<p class="text-gray-400 text-xs">Size: ${formatFileSize(log.file_size)}</p>` : ''}
                    </div>
                    <div class="flex items-center space-x-2">
                        <button onclick="previewLog('${log.id}')" 
                                class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm transition-colors"
                                title="Preview log">
                            👁️ Preview
                        </button>
                        <button onclick="downloadLogFile('${log.id}')" 
                                class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm transition-colors"
                                title="Download log file">
                            📥 Download
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
        
        container.innerHTML = logsHTML;
    }
    
    async function previewLog(logId) {
        try {
            showLogsStatus('Loading preview...', 'info');
            
            const response = await fetch(`/api/logs/${logId}?page=1&per_page=10`, {
                method: 'GET',
                credentials: 'same-origin'
            });
            
            if (!response.ok) {
                if (response.status === 404) {
                    showBasicPreview(logId);
                    return;
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success && result.entries && result.entries.length > 0) {
                showLogPreview(result.entries);
                showLogsStatus(`✅ Showing preview of ${result.entries.length} entries`, 'success');
            } else {
                showBasicPreview(logId);
            }
            
        } catch (error) {
            console.error('❌ Error previewing log:', error);
            showLogsStatus(`❌ Preview error: ${error.message}`, 'error');
            showBasicPreview(logId);
        }
    }
    
    function showBasicPreview(logId) {
        const basicInfo = [{
            timestamp: new Date().toISOString(),
            level: 'INFO',
            message: `Preview not available for log ${logId}. Download the full log file to view all entries.`,
            raw: `Log ID: ${logId} | Click "Download" to get the complete log file`
        }];
        
        showLogPreview(basicInfo);
        showLogsStatus('ℹ️ Showing basic info - download the full log file to view entries', 'info');
    }
    
    function downloadLogFile(logId) {
        const downloadUrl = `/api/logs/${logId}/download`;
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = `log_${logId}.json`;
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showLogsStatus('✅ Download started', 'success');
    }
    
    function showLogPreview(entries) {
        const previewContainer = document.getElementById('log-preview-container');
        const previewDiv = document.getElementById('log-preview');
        
        if (!previewContainer || !previewDiv) return;
        
        previewDiv.innerHTML = entries.map(entry => `
            <div class="border-b border-gray-700 pb-2 mb-2">
                <div class="flex items-center justify-between text-xs">
                    <span class="text-blue-400">${entry.timestamp || 'Unknown time'}</span>
                    <span class="text-purple-400">${entry.level || 'INFO'}</span>
                </div>
                <div class="text-gray-300 mt-1 font-mono text-sm">
                    ${escapeHtml(entry.message || entry.raw || 'No message')}
                </div>
            </div>
        `).join('');
        
        previewContainer.classList.remove('hidden');
    }
    
    function hideLogPreview() {
        const previewContainer = document.getElementById('log-preview-container');
        if (previewContainer) {
            previewContainer.classList.add('hidden');
        }
    }
    
    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    
    function escapeHtml(text) {
        if (!text) return '';
        if (typeof text !== 'string') return String(text);
        
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function formatFileSize(bytes) {
        if (!bytes) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    function showLogsStatus(message, type = 'info') {
        console.log(`📋 Logs Status [${type.toUpperCase()}]: ${message}`);
        
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            const iconMap = {
                'info': 'ℹ️',
                'success': '✅',
                'warning': '⚠️',
                'error': '❌'
            };
            
            const colorMap = {
                'info': 'text-blue-400',
                'success': 'text-green-400',
                'warning': 'text-yellow-400',
                'error': 'text-red-400'
            };
            
            statusDiv.innerHTML = `
                <div class="${colorMap[type] || 'text-gray-400'} text-sm">
                    ${iconMap[type] || 'ℹ️'} ${message}
                </div>
            `;
            statusDiv.classList.remove('hidden');
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => hideLogsStatus(), 5000);
            }
        }
    }
    
    function hideLogsStatus() {
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            statusDiv.classList.add('hidden');
        }
    }
    
    // ============================================================================
    // PLAYER COUNT & AUTO COMMANDS
    // ============================================================================
    
    async function getPlayerCountFromLogs(serverId) {
        try {
            const response = await fetch(`/api/logs/player-count/${serverId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const result = await response.json();
            if (result.success) {
                console.log(`✅ Got player count: ${result.current_players}/${result.max_players}`);
                return result;
            } else {
                throw new Error(result.error || 'Failed to get player count');
            }
        } catch (error) {
            console.error(`❌ Error getting player count: ${error.message}`);
            return null;
        }
    }
    
    const autoConsoleConfig = {
        enabled: true,
        interval: 10000,
        commands: ['serverinfo'],
        maxConcurrent: 2
    };
    
    let autoConsoleInterval = null;
    let autoCommandsRunning = false;
    
    function getAvailableServersForAutoCommands() {
        if (window.managedServers) {
            return window.managedServers.filter(server => 
                server.isActive && (server.status === 'online' || server.status === 'connected')
            );
        }
        return [];
    }
    
    async function startAutoConsoleCommands() {
        if (autoCommandsRunning) return;
        
        console.log('🚀 Starting automatic console commands...');
        autoCommandsRunning = true;
        
        const sendCommands = async () => {
            try {
                const servers = getAvailableServersForAutoCommands();
                if (servers.length === 0) return;
                
                console.log(`📡 Auto-sending commands to ${servers.length} servers...`);
                
                for (let i = 0; i < Math.min(servers.length, autoConsoleConfig.maxConcurrent); i++) {
                    const server = servers[i];
                    if (typeof window.sendConsoleCommand === 'function') {
                        await window.sendConsoleCommand('serverinfo', server.serverId);
                        setTimeout(() => getPlayerCountFromLogs(server.serverId), 3000);
                    }
                }
            } catch (error) {
                console.error('❌ Error in auto commands:', error);
            }
        };
        
        await sendCommands();
        autoConsoleInterval = setInterval(sendCommands, autoConsoleConfig.interval);
    }
    
    function stopAutoConsoleCommands() {
        if (autoConsoleInterval) {
            clearInterval(autoConsoleInterval);
            autoConsoleInterval = null;
        }
        autoCommandsRunning = false;
        console.log('🛑 Auto console commands stopped');
    }
    
    // ============================================================================
    // FUNCTION EXPOSURE
    // ============================================================================
    
    if (typeof window !== 'undefined') {
        window.loadLogs = loadLogs;
        window.showLogsTab = showLogsTab;
        window.initializeLogs = initializeLogs;
        window.downloadLogs = downloadLogs;
        window.refreshLogs = refreshLogs;
        window.previewLog = previewLog;
        window.downloadLogFile = downloadLogFile;
        window.hideLogPreview = hideLogPreview;
        window.showLogsStatus = showLogsStatus;
        window.hideLogsStatus = hideLogsStatus;
        window.getPlayerCountFromLogs = getPlayerCountFromLogs;
        window.startAutoConsoleCommands = startAutoConsoleCommands;
        window.stopAutoConsoleCommands = stopAutoConsoleCommands;
        
        console.log('✅ All logs functions exposed to window');
    }
    
    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('📋 Logs module ready (FINAL VERSION)');
        
        if (window.location.hash === '#logs') {
            setTimeout(initializeLogs, 100);
        }
        
        if (typeof window.tabInitializers === 'undefined') {
            window.tabInitializers = {};
        }
        window.tabInitializers.logs = initializeLogs;
        
        // Start final dropdown solution
        setTimeout(() => {
            console.log('🎯 Starting FINAL dropdown solution...');
            startFinalDropdownSolution();
        }, 1000);
        
        // Start auto commands
        setTimeout(() => {
            if (autoConsoleConfig.enabled) {
                const servers = getAvailableServersForAutoCommands();
                if (servers.length > 0) {
                    startAutoConsoleCommands();
                } else {
                    const serverCheck = setInterval(() => {
                        const availableServers = getAvailableServersForAutoCommands();
                        if (availableServers.length > 0) {
                            clearInterval(serverCheck);
                            startAutoConsoleCommands();
                        }
                    }, 3000);
                    
                    setTimeout(() => clearInterval(serverCheck), 30000);
                }
            }
        }, 5000);
    });
    
    console.log('🎯 Logs module LOADED (FINAL VERSION - CORRECT FILE TARGETED)');
    
</script>
