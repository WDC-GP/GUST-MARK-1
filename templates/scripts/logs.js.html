<script>
    // ============================================================================
    // LOGS MODULE (FINAL CONFLICT-PROTECTED VERSION WITH AUTO COMMAND FIXES)
    // ============================================================================
    
    console.log('üìã Loading Logs module with FINAL conflict protection and auto command fixes...');
    
    function showLogsTab() {
        console.log('üìã Showing Logs tab...');
        
        // Hide other views
        const views = ['dashboard-view', 'server-manager-view', 'console-view', 'server-health', 'events-view', 'economy-view', 'gambling-view', 'clans-view', 'user-management-view'];
        views.forEach(viewId => {
            const view = document.getElementById(viewId);
            if (view) {
                view.style.display = 'none';
            }
        });
        
        // Show logs view
        const logsView = document.getElementById('logs-view');
        if (logsView) {
            logsView.style.display = 'block';
            
            // Activate tab
            const tabs = document.querySelectorAll('.tab-button');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            const logsTab = document.querySelector('[data-tab="logs"]');
            if (logsTab) {
                logsTab.classList.add('active');
            }
        }
        
        setTimeout(() => {
            if (typeof initializeLogs === 'function') {
                initializeLogs();
            }
            loadLogs();
            
            // Start final dropdown solution
            console.log('üéØ Starting FINAL dropdown solution...');
            startFinalDropdownSolution();
        }, 100);
    }
    
    function initializeLogs() {
        console.log('üîß Initializing Logs functionality...');
        
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            statusDiv.innerHTML = `
                <div class="text-green-400 text-sm">
                    ‚úÖ Logs module initialized (FINAL VERSION WITH AUTO COMMANDS)
                </div>
            `;
            statusDiv.classList.remove('hidden');
        }
        
        // Start automatic command system with proper initialization
        setTimeout(() => {
            initializeAutoConsoleCommands();
        }, 3000);
        
        console.log('‚úÖ Logs initialization complete');
    }
    
    function loadLogs() {
        console.log('üìã Loading logs...');
        setTimeout(() => {
            refreshLogs();
        }, 500);
    }
    
    // ============================================================================
    // ‚úÖ FINAL DROPDOWN SOLUTION
    // ============================================================================
    
    function startFinalDropdownSolution() {
        console.log('üéØ Starting FINAL dropdown solution...');
        
        // Ultimate dropdown population that always works
        function ultimatePopulateDropdown() {
            const dropdown = document.getElementById('server-select');
            if (!dropdown) {
                console.warn('‚ö†Ô∏è Dropdown not found');
                return false;
            }
            
            if (!window.managedServers || window.managedServers.length === 0) {
                dropdown.innerHTML = '<option value="">Loading servers...</option>';
                return false;
            }
            
            console.log(`üéØ ULTIMATE population with ${window.managedServers.length} servers...`);
            
            // Clear and repopulate
            dropdown.innerHTML = '<option value="">Select a server...</option>';
            
            let added = 0;
            window.managedServers.forEach((server, index) => {
                if (server.serverId) {
                    const option = document.createElement('option');
                    option.value = server.serverId;
                    
                    // FINAL status detection - prioritize showing ONLINE
                    let status = 'UNKNOWN';
                    if (server.status && typeof server.status === 'string') {
                        const serverStatus = server.status.toLowerCase();
                        if (serverStatus === 'online' || serverStatus === 'active' || serverStatus === 'connected') {
                            status = 'ONLINE';
                        } else if (serverStatus === 'offline' || serverStatus === 'inactive') {
                            status = 'OFFLINE';
                        }
                    } else if (server.isActive === true) {
                        // If server is active, assume online
                        status = 'ONLINE';
                    } else if (server.isActive === false) {
                        status = 'OFFLINE';
                    }
                    
                    option.textContent = `${server.serverName} (${server.serverId}) [${status}]`;
                    
                    // Apply styling
                    if (status === 'ONLINE') {
                        option.style.color = '#10B981';
                        option.style.fontWeight = 'bold';
                    } else if (status === 'OFFLINE') {
                        option.style.color = '#F59E0B';
                    } else {
                        option.style.color = '#6B7280';
                    }
                    
                    dropdown.appendChild(option);
                    added++;
                    
                    console.log(`üéØ ULTIMATE ADD: ${server.serverName} [${status}]`);
                } else {
                    console.warn(`‚ö†Ô∏è Server ${index + 1} missing serverId:`, server);
                }
            });
            
            console.log(`üéØ ULTIMATE population complete: ${added} servers added`);
            
            if (typeof showLogsStatus === 'function') {
                showLogsStatus(`üéØ ${added} servers loaded (FINAL VERSION)`, 'success');
            }
            
            return true;
        }
        
        // Replace global functions
        window.populateServerDropdown = ultimatePopulateDropdown;
        window.forceRefreshServerDropdown = ultimatePopulateDropdown;
        
        // Immediate population
        ultimatePopulateDropdown();
        
        // FINAL monitoring - very aggressive (every 3 seconds)
        setInterval(() => {
            const dropdown = document.getElementById('server-select');
            if (!dropdown) return;
            
            const hasServers = window.managedServers && window.managedServers.length > 0;
            const expectedOptions = hasServers ? window.managedServers.length + 1 : 1;
            const actualOptions = dropdown.options.length;
            
            // If options don't match OR if any server shows UNKNOWN, re-populate
            const hasUnknown = Array.from(dropdown.options).some(opt => 
                opt.textContent.includes('[UNKNOWN]')
            );
            
            if ((hasServers && actualOptions !== expectedOptions) || hasUnknown) {
                console.log(`üö® FINAL MONITOR: Fixing dropdown (expected: ${expectedOptions}, actual: ${actualOptions}, hasUnknown: ${hasUnknown})`);
                ultimatePopulateDropdown();
            }
        }, 3000); // Check every 3 seconds
        
        // Event listeners
        document.addEventListener('managedServersLoaded', () => {
            console.log('üì° managedServersLoaded - FINAL re-population');
            setTimeout(ultimatePopulateDropdown, 100);
        });
        
        // Multiple fallback attempts
        [1000, 3000, 5000, 10000, 15000].forEach(delay => {
            setTimeout(() => {
                const dropdown = document.getElementById('server-select');
                if (dropdown && window.managedServers?.length > 0) {
                    const hasUnknown = Array.from(dropdown.options).some(opt => 
                        opt.textContent.includes('[UNKNOWN]')
                    );
                    if (dropdown.options.length <= 1 || hasUnknown) {
                        console.log(`üîÑ FINAL fallback (${delay}ms): Re-populating...`);
                        ultimatePopulateDropdown();
                    }
                }
            }, delay);
        });
        
        console.log('üéØ FINAL dropdown solution active');
    }
    
    // ============================================================================
    // LOG MANAGEMENT FUNCTIONS (UNCHANGED)
    // ============================================================================
    
    async function downloadLogs() {
        const serverSelect = document.getElementById('server-select');
        const downloadBtn = document.getElementById('download-logs-btn');
        
        if (!serverSelect || !serverSelect.value) {
            showLogsStatus('Please select a server first', 'warning');
            return;
        }
        
        const serverId = serverSelect.value;
        
        try {
            if (downloadBtn) {
                downloadBtn.disabled = true;
                downloadBtn.textContent = '‚è≥ Downloading...';
            }
            
            showLogsStatus('Downloading logs from server...', 'info');
            
            const response = await fetch('/api/logs/download', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'same-origin',
                body: JSON.stringify({
                    server_id: serverId
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success) {
                showLogsStatus(`‚úÖ Downloaded ${result.entries_count || 0} log entries`, 'success');
                setTimeout(() => refreshLogs(), 1000);
            } else {
                throw new Error(result.error || 'Download failed');
            }
            
        } catch (error) {
            console.error('‚ùå Error downloading logs:', error);
            showLogsStatus(`‚ùå Download failed: ${error.message}`, 'error');
        } finally {
            if (downloadBtn) {
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'üì• Download Logs';
            }
        }
    }
    
    async function refreshLogs() {
        console.log('üîÑ Refreshing logs list...');
        
        const refreshBtn = document.getElementById('refresh-logs-btn');
        
        try {
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.textContent = '‚è≥ Refreshing...';
            }
            
            showLogsStatus('Refreshing logs list...', 'info');
            
            const response = await fetch('/api/logs', {
                method: 'GET',
                credentials: 'same-origin'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success) {
                displayLogsList(result.logs || []);
                showLogsStatus(`‚úÖ Loaded ${result.logs?.length || 0} log files`, 'success');
            } else {
                throw new Error(result.error || 'Failed to load logs');
            }
            
        } catch (error) {
            console.error('‚ùå Error refreshing logs:', error);
            showLogsStatus(`‚ùå Refresh failed: ${error.message}`, 'error');
        } finally {
            if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'üîÑ Refresh';
            }
        }
    }
    
    function displayLogsList(logs) {
        const container = document.getElementById('logs-list');
        if (!container) return;
        
        if (!logs || logs.length === 0) {
            container.innerHTML = `
                <div class="text-gray-400 text-center py-8">
                    <div class="text-4xl mb-4">üìã</div>
                    <div>No logs available</div>
                    <div class="text-sm mt-2">Download logs from your servers to see them here</div>
                </div>
            `;
            return;
        }
        
        const logsHTML = logs.map(log => `
            <div class="bg-gray-700 p-4 rounded-lg border border-gray-600">
                <div class="flex items-center justify-between">
                    <div class="flex-1">
                        <h4 class="font-semibold text-lg">${escapeHtml(log.server_name || 'Unknown Server')}</h4>
                        <p class="text-gray-400 text-sm">Server ID: ${escapeHtml(log.server_id || 'N/A')}</p>
                        <p class="text-gray-400 text-xs">Downloaded: ${new Date(log.timestamp || log.download_time).toLocaleString()}</p>
                        <p class="text-gray-400 text-xs">Entries: ${log.parsed_entries || log.entries_count || 0}</p>
                        ${log.file_size ? `<p class="text-gray-400 text-xs">Size: ${formatFileSize(log.file_size)}</p>` : ''}
                    </div>
                    <div class="flex items-center space-x-2">
                        <button onclick="previewLog('${log.id}')" 
                                class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm transition-colors"
                                title="Preview log">
                            üëÅÔ∏è Preview
                        </button>
                        <button onclick="downloadLogFile('${log.id}')" 
                                class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm transition-colors"
                                title="Download log file">
                            üì• Download
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
        
        container.innerHTML = logsHTML;
    }
    
    async function previewLog(logId) {
        try {
            showLogsStatus('Loading preview...', 'info');
            
            const response = await fetch(`/api/logs/${logId}?page=1&per_page=10`, {
                method: 'GET',
                credentials: 'same-origin'
            });
            
            if (!response.ok) {
                if (response.status === 404) {
                    showBasicPreview(logId);
                    return;
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success && result.entries && result.entries.length > 0) {
                showLogPreview(result.entries);
                showLogsStatus(`‚úÖ Showing preview of ${result.entries.length} entries`, 'success');
            } else {
                showBasicPreview(logId);
            }
            
        } catch (error) {
            console.error('‚ùå Error previewing log:', error);
            showLogsStatus(`‚ùå Preview error: ${error.message}`, 'error');
            showBasicPreview(logId);
        }
    }
    
    function showBasicPreview(logId) {
        const basicInfo = [{
            timestamp: new Date().toISOString(),
            level: 'INFO',
            message: `Preview not available for log ${logId}. Download the full log file to view all entries.`,
            raw: `Log ID: ${logId} | Click "Download" to get the complete log file`
        }];
        
        showLogPreview(basicInfo);
        showLogsStatus('‚ÑπÔ∏è Showing basic info - download the full log file to view entries', 'info');
    }
    
    function downloadLogFile(logId) {
        const downloadUrl = `/api/logs/${logId}/download`;
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = `log_${logId}.json`;
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showLogsStatus('‚úÖ Download started', 'success');
    }
    
    function showLogPreview(entries) {
        const previewContainer = document.getElementById('log-preview-container');
        const previewDiv = document.getElementById('log-preview');
        
        if (!previewContainer || !previewDiv) return;
        
        previewDiv.innerHTML = entries.map(entry => `
            <div class="border-b border-gray-700 pb-2 mb-2">
                <div class="flex items-center justify-between text-xs">
                    <span class="text-blue-400">${entry.timestamp || 'Unknown time'}</span>
                    <span class="text-purple-400">${entry.level || 'INFO'}</span>
                </div>
                <div class="text-gray-300 mt-1 font-mono text-sm">
                    ${escapeHtml(entry.message || entry.raw || 'No message')}
                </div>
            </div>
        `).join('');
        
        previewContainer.classList.remove('hidden');
    }
    
    function hideLogPreview() {
        const previewContainer = document.getElementById('log-preview-container');
        if (previewContainer) {
            previewContainer.classList.add('hidden');
        }
    }
    
    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    
    function escapeHtml(text) {
        if (!text) return '';
        if (typeof text !== 'string') return String(text);
        
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function formatFileSize(bytes) {
        if (!bytes) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    function showLogsStatus(message, type = 'info') {
        console.log(`üìã Logs Status [${type.toUpperCase()}]: ${message}`);
        
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            const iconMap = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'warning': '‚ö†Ô∏è',
                'error': '‚ùå'
            };
            
            const colorMap = {
                'info': 'text-blue-400',
                'success': 'text-green-400',
                'warning': 'text-yellow-400',
                'error': 'text-red-400'
            };
            
            statusDiv.innerHTML = `
                <div class="${colorMap[type] || 'text-gray-400'} text-sm">
                    ${iconMap[type] || '‚ÑπÔ∏è'} ${message}
                </div>
            `;
            statusDiv.classList.remove('hidden');
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => hideLogsStatus(), 5000);
            }
        }
    }
    
    function hideLogsStatus() {
        const statusDiv = document.getElementById('logs-status');
        if (statusDiv) {
            statusDiv.classList.add('hidden');
        }
    }
    
    // ============================================================================
    // ‚úÖ FIXED PLAYER COUNT & AUTO COMMANDS SYSTEM
    // ============================================================================
    
    async function getPlayerCountFromLogs(serverId) {
        try {
            const response = await fetch(`/api/logs/player-count/${serverId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const result = await response.json();
            if (result.success) {
                console.log(`‚úÖ Got player count: ${result.current_players}/${result.max_players}`);
                return result;
            } else {
                throw new Error(result.error || 'Failed to get player count');
            }
        } catch (error) {
            console.error(`‚ùå Error getting player count: ${error.message}`);
            return null;
        }
    }
    
    // ‚úÖ FIXED: Auto console configuration
    const autoConsoleConfig = {
        enabled: true,
        interval: 10000,        // 10 seconds
        commands: ['serverinfo'],
        maxConcurrent: 2,
        waitForServers: true,   // NEW: Wait for servers to load
        maxWaitTime: 30000,     // NEW: Max wait time for servers
        retryAttempts: 3        // NEW: Retry attempts for failed commands
    };
    
    let autoConsoleInterval = null;
    let autoCommandsRunning = false;
    let autoCommandsInitialized = false;
    
    // ‚úÖ FIXED: Get available servers for auto commands
    function getAvailableServersForAutoCommands() {
        if (!window.managedServers || !Array.isArray(window.managedServers)) {
            console.log('ü§ñ No managedServers available for auto commands');
            return [];
        }
        
        const availableServers = window.managedServers.filter(server => {
            if (!server || !server.serverId) {
                return false;
            }
            
            // Check if server is active
            const isActive = server.isActive === true;
            
            // Check server status
            const hasOnlineStatus = server.status && 
                ['online', 'active', 'connected'].includes(server.status.toLowerCase());
            
            return isActive || hasOnlineStatus;
        });
        
        console.log(`ü§ñ Found ${availableServers.length} available servers for auto commands:`, 
            availableServers.map(s => `${s.serverName} (${s.serverId})`));
        
        return availableServers;
    }
    
    // ‚úÖ NEW: Wait for servers to be loaded
    function waitForServersToLoad() {
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            const checkServers = () => {
                const servers = getAvailableServersForAutoCommands();
                
                if (servers.length > 0) {
                    console.log(`ü§ñ Servers loaded! Found ${servers.length} servers`);
                    resolve(servers);
                    return;
                }
                
                // Check if we've exceeded max wait time
                if (Date.now() - startTime > autoConsoleConfig.maxWaitTime) {
                    console.warn(`ü§ñ Timeout waiting for servers (${autoConsoleConfig.maxWaitTime}ms)`);
                    resolve([]); // Resolve with empty array instead of rejecting
                    return;
                }
                
                // Try again in 1 second
                setTimeout(checkServers, 1000);
            };
            
            checkServers();
        });
    }
    
    // ‚úÖ FIXED: Auto command initialization
    async function initializeAutoConsoleCommands() {
        if (autoCommandsInitialized) {
            console.log('ü§ñ Auto commands already initialized');
            return;
        }
        
        console.log('ü§ñ Initializing auto console commands...');
        autoCommandsInitialized = true;
        
        // Check if sendConsoleCommandAuto function exists
        if (typeof window.sendConsoleCommandAuto !== 'function') {
            console.error('‚ùå sendConsoleCommandAuto function not found! Auto commands disabled.');
            showLogsStatus('Auto commands disabled: sendConsoleCommandAuto function missing', 'error');
            return;
        }
        
        if (autoConsoleConfig.waitForServers) {
            console.log('ü§ñ Waiting for servers to load...');
            showLogsStatus('Waiting for servers to load for auto commands...', 'info');
            
            const servers = await waitForServersToLoad();
            
            if (servers.length === 0) {
                console.warn('ü§ñ No servers available for auto commands');
                showLogsStatus('No servers available for auto commands', 'warning');
                return;
            }
        }
        
        // Start auto commands
        startAutoConsoleCommands();
    }
    
    // ‚úÖ FIXED: Start auto console commands
    async function startAutoConsoleCommands() {
        if (autoCommandsRunning) {
            console.log('ü§ñ Auto commands already running');
            return;
        }
        
        console.log('üöÄ Starting automatic console commands...');
        autoCommandsRunning = true;
        
        const sendCommands = async () => {
            try {
                const servers = getAvailableServersForAutoCommands();
                if (servers.length === 0) {
                    console.log('ü§ñ No servers available for auto commands, skipping...');
                    return;
                }
                
                console.log(`üì° Auto-sending commands to ${servers.length} servers...`);
                
                // Send commands to servers (respecting maxConcurrent limit)
                const serversToProcess = servers.slice(0, autoConsoleConfig.maxConcurrent);
                
                for (const server of serversToProcess) {
                    try {
                        console.log(`ü§ñ Sending serverinfo to ${server.serverName} (${server.serverId})`);
                        
                        // ‚úÖ FIXED: Use the new sendConsoleCommandAuto function
                        const result = await window.sendConsoleCommandAuto(
                            'serverinfo', 
                            server.serverId, 
                            server.serverRegion || 'US'
                        );
                        
                        if (result.success) {
                            console.log(`‚úÖ Auto command success for ${server.serverName}`);
                            
                            // Trigger logs-based player count update after delay
                            setTimeout(() => {
                                getPlayerCountFromLogs(server.serverId);
                            }, 3000);
                        } else {
                            console.warn(`‚ö†Ô∏è Auto command failed for ${server.serverName}: ${result.error}`);
                        }
                        
                    } catch (error) {
                        console.error(`‚ùå Error sending auto command to ${server.serverName}:`, error);
                    }
                    
                    // Small delay between servers to avoid overwhelming the API
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
            } catch (error) {
                console.error('‚ùå Error in auto commands cycle:', error);
            }
        };
        
        // Send commands immediately
        await sendCommands();
        
        // Set up interval for continuous commands
        autoConsoleInterval = setInterval(sendCommands, autoConsoleConfig.interval);
        
        showLogsStatus(`ü§ñ Auto commands started (every ${autoConsoleConfig.interval/1000}s)`, 'success');
        console.log(`ü§ñ Auto commands running every ${autoConsoleConfig.interval/1000} seconds`);
    }
    
    // ‚úÖ FIXED: Stop auto console commands
    function stopAutoConsoleCommands() {
        if (autoConsoleInterval) {
            clearInterval(autoConsoleInterval);
            autoConsoleInterval = null;
        }
        autoCommandsRunning = false;
        console.log('üõë Auto console commands stopped');
        showLogsStatus('Auto commands stopped', 'info');
    }
    
    // ‚úÖ NEW: Force refresh auto commands (restart with new server list)
    async function forceRefreshAutoCommands() {
        console.log('üîÑ Force refreshing auto commands...');
        
        stopAutoConsoleCommands();
        autoCommandsInitialized = false;
        
        // Wait a moment then restart
        setTimeout(() => {
            initializeAutoConsoleCommands();
        }, 2000);
    }
    
    // ============================================================================
    // FUNCTION EXPOSURE
    // ============================================================================
    
    if (typeof window !== 'undefined') {
        window.loadLogs = loadLogs;
        window.showLogsTab = showLogsTab;
        window.initializeLogs = initializeLogs;
        window.downloadLogs = downloadLogs;
        window.refreshLogs = refreshLogs;
        window.previewLog = previewLog;
        window.downloadLogFile = downloadLogFile;
        window.hideLogPreview = hideLogPreview;
        window.showLogsStatus = showLogsStatus;
        window.hideLogsStatus = hideLogsStatus;
        window.getPlayerCountFromLogs = getPlayerCountFromLogs;
        window.startAutoConsoleCommands = startAutoConsoleCommands;
        window.stopAutoConsoleCommands = stopAutoConsoleCommands;
        window.initializeAutoConsoleCommands = initializeAutoConsoleCommands;  // ‚úÖ NEW
        window.forceRefreshAutoCommands = forceRefreshAutoCommands;  // ‚úÖ NEW
        
        console.log('‚úÖ All logs functions exposed to window (including auto command fixes)');
    }
    
    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('üìã Logs module ready (FINAL VERSION WITH AUTO COMMAND FIXES)');
        
        if (window.location.hash === '#logs') {
            setTimeout(initializeLogs, 100);
        }
        
        if (typeof window.tabInitializers === 'undefined') {
            window.tabInitializers = {};
        }
        window.tabInitializers.logs = initializeLogs;
        
        // Start final dropdown solution
        setTimeout(() => {
            console.log('üéØ Starting FINAL dropdown solution...');
            startFinalDropdownSolution();
        }, 1000);
        
        // ‚úÖ FIXED: Start auto commands with proper initialization
        setTimeout(() => {
            if (autoConsoleConfig.enabled) {
                console.log('ü§ñ Auto console commands enabled, starting initialization...');
                initializeAutoConsoleCommands();
            } else {
                console.log('ü§ñ Auto console commands disabled in config');
            }
        }, 5000);
        
        // Listen for server loading events
        document.addEventListener('managedServersLoaded', () => {
            console.log('üì° managedServersLoaded event - checking auto commands');
            if (autoConsoleConfig.enabled && !autoCommandsRunning) {
                setTimeout(() => {
                    initializeAutoConsoleCommands();
                }, 1000);
            }
        });
    });
    
    console.log('üéØ Logs module LOADED (FINAL VERSION WITH AUTO COMMAND FIXES)');
    console.log('ü§ñ Auto command system: Using sendConsoleCommandAuto() with /api/console/send-auto endpoint');
    
</script>