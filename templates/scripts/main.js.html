<!-- ============================================================================
     GUST Bot Enhanced - Core JavaScript (COMPLETE FIXED VERSION)
     ============================================================================
     ✅ CRITICAL FIX: Proper managedServers array initialization with protection
     ✅ CRITICAL FIX: Emergency recovery functions integrated
     ✅ CRITICAL FIX: Auto-loading server functionality
     ✅ FIXED: Request queue timeout increased to 2 minutes (was 90s)
     ✅ FIXED: Proper timeout clearing when requests start processing
     ✅ FIXED: Enhanced module loading with availability checks
     ✅ FIXED: Better error handling and recovery mechanisms
     ✅ FIXED: Non-blocking queue processing with retry logic
     ✅ CRITICAL FIX: Removed circular dependency between getStats() and isHealthy()
     ============================================================================ -->

<script>
    // ============================================================================
    // ENHANCED CONFIGURATION WITH FIXED TIMEOUTS
    // ============================================================================
    
    const ENHANCED_CONFIG = {
        POLLING_INTERVALS: {
            servers: 15000,          // 15s (more conservative)
            player_count: 30000,     // 30s (less frequent)
            console: 20000,          // 20s (reduced load)
            server_health: 120000    // 2min (background only)
        },
        
        REQUEST_THROTTLING: {
            maxConcurrent: 2,        // Reduced concurrency
            minInterval: 1000,       // 1s between requests
            queueTimeout: 120000     // ✅ CRITICAL: 2 minutes (was 90s)
        },
        
        AUTH_RECOVERY: {
            maxFailures: 5,          // More patient
            retryDelay: 3000,        // 3s between retries
            exponentialBackoff: true,
            redirectAfterFailures: 8  // Very patient
        }
    };
    
    // ============================================================================
    // ✅ CRITICAL FIX: PROPER GLOBAL VARIABLES WITH ARRAY PROTECTION
    // ============================================================================
    
    let currentTab = 'dashboard';
    let servers = [];               // ✅ Initialize as array
    let managedServers = [];        // ✅ CRITICAL: Initialize as array
    let selectedServers = new Set(); // ✅ Initialize as Set
    let wsConnection = null;
    let isDemo = false;
    let connectionStatus = {};      // ✅ Initialize as object
    let serverFilter = '';
    let messageTypeFilter = 'all';
    let autoScroll = true;
    let websocketsAvailable = true;
    
    // ✅ CRITICAL: Array protection flag
    let arrayInitialized = false;

    // ============================================================================
    // ✅ CRITICAL: ARRAY VALIDATION AND PROTECTION FUNCTIONS
    // ============================================================================
    
    /**
     * ✅ CRITICAL: Validate and fix managedServers array state
     */
    function validateManagedServers() {
        let fixed = false;
        
        if (!Array.isArray(window.managedServers)) {
            console.error('❌ CRITICAL: window.managedServers is not an array!');
            console.log(`🔧 Type detected: ${typeof window.managedServers}`);
            window.managedServers = [];
            managedServers = [];
            fixed = true;
        }
        
        if (!Array.isArray(managedServers)) {
            console.error('❌ CRITICAL: managedServers is not an array!');
            managedServers = [];
            window.managedServers = managedServers;
            fixed = true;
        }
        
        // Sync both references
        if (window.managedServers !== managedServers) {
            console.log('🔧 Syncing managedServers references');
            window.managedServers = managedServers;
            fixed = true;
        }
        
        if (fixed) {
            console.log('✅ managedServers array state fixed');
        }
        
        return !fixed; // Return true if validation passed without fixes
    }
    
    /**
     * ✅ CRITICAL: Emergency fix for managedServers
     */
    function fixManagedServers() {
        console.log('🚑 Emergency managedServers fix...');
        
        // Force reset to empty arrays
        managedServers = [];
        window.managedServers = [];
        
        // Clean any corrupted data
        if (window.selectedServers && !(window.selectedServers instanceof Set)) {
            window.selectedServers = new Set();
            selectedServers = new Set();
        }
        
        console.log('✅ managedServers emergency fix complete');
        
        // Try to reload servers from API
        setTimeout(() => {
            if (typeof loadManagedServers === 'function') {
                console.log('🔄 Attempting to reload servers after fix...');
                loadManagedServers().catch(error => {
                    console.warn('⚠️ Server reload failed after fix:', error);
                });
            }
        }, 1000);
        
        return true;
    }
    
    /**
     * ✅ CRITICAL: Safe array operation wrapper
     */
    function safeArrayOperation(arrayName, operation, ...args) {
        const array = window[arrayName];
        
        if (!Array.isArray(array)) {
            console.warn(`⚠️ ${arrayName} is not an array, fixing...`);
            window[arrayName] = [];
            
            if (arrayName === 'managedServers') {
                managedServers = [];
            }
            
            return operation === 'length' ? 0 : operation === 'find' ? undefined : [];
        }
        
        if (typeof array[operation] === 'function') {
            return array[operation](...args);
        } else if (operation === 'length') {
            return array.length;
        }
        
        return undefined;
    }
    
    /**
     * ✅ CRITICAL: Enhanced loadManagedServers with protection
     */
    async function loadManagedServers() {
        console.log('📡 Loading managed servers (PROTECTED VERSION)...');
        
        try {
            // Ensure array state first
            validateManagedServers();
            
            const response = await enhancedFetch('/api/servers');
            
            if (response && response.success && Array.isArray(response.servers)) {
                // Safe assignment
                managedServers = response.servers;
                window.managedServers = managedServers;
                
                console.log(`✅ Loaded ${response.servers.length} managed servers successfully`);
                
                // Trigger update events
                if (typeof updateAllServerDropdowns === 'function') {
                    updateAllServerDropdowns();
                }
                
                // Dispatch custom event for other modules
                window.dispatchEvent(new CustomEvent('serversLoaded', {
                    detail: { servers: response.servers }
                }));
                
                return response.servers;
            } else {
                console.warn('⚠️ Invalid server response format');
                return [];
            }
            
        } catch (error) {
            console.error('❌ Error loading managed servers:', error);
            
            // Ensure arrays are still valid after error
            validateManagedServers();
            
            throw error;
        }
    }

    // ============================================================================
    // ✅ FIXED REQUEST QUEUE CLASS WITH PROPER TIMEOUT HANDLING
    // ============================================================================
    
    class RequestQueue {
        constructor(maxConcurrent = 2, minInterval = 1000) {
            this.maxConcurrent = maxConcurrent;
            this.minInterval = minInterval;
            this.activeRequests = 0;
            this.requestQueue = [];
            this.lastRequestTime = 0;
            this.isProcessing = false;
            this.failedRequests = 0;
            this.successfulRequests = 0;
            this.queueTimeout = ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout;
            
            console.log(`✅ Fixed RequestQueue initialized: max ${maxConcurrent} concurrent, ${minInterval}ms interval, ${this.queueTimeout/1000}s timeout`);
        }
        
        /**
         * ✅ CRITICAL FIX: Improved enqueue with proper timeout management
         */
        async enqueue(requestFunction, priority = 'normal') {
            return new Promise((resolve, reject) => {
                const queueItem = {
                    requestFunction,
                    resolve,
                    reject,
                    priority,
                    timestamp: Date.now(),
                    timeout: null,
                    id: Math.random().toString(36).substr(2, 9),
                    attempts: 0,
                    maxAttempts: 3
                };
                
                // ✅ FIXED: Set timeout with proper cleanup tracking
                queueItem.timeout = setTimeout(() => {
                    console.warn(`⏰ Request timeout: ${queueItem.id} after ${this.queueTimeout/1000}s`);
                    
                    // Remove from queue if still there
                    const index = this.requestQueue.findIndex(item => item.id === queueItem.id);
                    if (index > -1) {
                        this.requestQueue.splice(index, 1);
                        console.log(`🗑️ Removed timed-out request from queue: ${queueItem.id}`);
                    }
                    
                    this.failedRequests++;
                    reject(new Error(`Request timeout after ${this.queueTimeout/1000}s - server may be busy or request too complex`));
                }, this.queueTimeout);
                
                // Insert based on priority
                if (priority === 'high') {
                    this.requestQueue.unshift(queueItem);
                } else {
                    this.requestQueue.push(queueItem);
                }
                
                console.log(`📝 Queued request ${queueItem.id} (priority: ${priority}, queue: ${this.requestQueue.length})`);
                
                // Start processing (non-blocking)
                this.processQueueAsync();
            });
        }
        
        /**
         * ✅ FIXED: Non-blocking queue processing trigger
         */
        processQueueAsync() {
            if (!this.isProcessing && this.requestQueue.length > 0) {
                setTimeout(() => this.processQueue(), 10);
            }
        }
        
        /**
         * ✅ CRITICAL FIX: Improved queue processing with proper timeout clearing
         */
        async processQueue() {
            // Prevent multiple simultaneous processing
            if (this.isProcessing) {
                return;
            }
            
            // No items to process
            if (this.requestQueue.length === 0) {
                return;
            }
            
            // Too many active requests - wait and retry
            if (this.activeRequests >= this.maxConcurrent) {
                console.log(`⏸️ Queue paused: ${this.activeRequests}/${this.maxConcurrent} active requests`);
                setTimeout(() => this.processQueue(), 1000);
                return;
            }
            
            this.isProcessing = true;
            
            try {
                // Check minimum interval between requests
                const now = Date.now();
                const timeSinceLastRequest = now - this.lastRequestTime;
                if (timeSinceLastRequest < this.minInterval) {
                    const waitTime = this.minInterval - timeSinceLastRequest;
                    console.log(`⏱️ Waiting ${waitTime}ms before next request (rate limiting)`);
                    setTimeout(() => {
                        this.isProcessing = false;
                        this.processQueue();
                    }, waitTime);
                    return;
                }
                
                // Get next request
                const queueItem = this.requestQueue.shift();
                if (!queueItem) {
                    this.isProcessing = false;
                    return;
                }
                
                // ✅ CRITICAL FIX: Clear timeout IMMEDIATELY when processing starts
                if (queueItem.timeout) {
                    clearTimeout(queueItem.timeout);
                    queueItem.timeout = null;
                    console.log(`✅ Cleared timeout for processing request: ${queueItem.id}`);
                }
                
                this.activeRequests++;
                this.lastRequestTime = now;
                
                console.log(`🔥 Processing request ${queueItem.id} (${this.activeRequests}/${this.maxConcurrent} active, ${this.requestQueue.length} queued)`);
                
                try {
                    // Execute the actual request
                    const result = await queueItem.requestFunction();
                    queueItem.resolve(result);
                    this.successfulRequests++;
                    console.log(`✅ Request ${queueItem.id} completed successfully`);
                    
                } catch (error) {
                    console.error(`❌ Request ${queueItem.id} failed (attempt ${queueItem.attempts + 1}):`, error);
                    
                    // ✅ ENHANCED: Retry logic with exponential backoff
                    queueItem.attempts++;
                    if (queueItem.attempts < queueItem.maxAttempts && this.shouldRetry(error)) {
                        const retryDelay = 2000 * Math.pow(2, queueItem.attempts - 1); // Exponential backoff
                        console.log(`🔄 Retrying request ${queueItem.id} in ${retryDelay}ms (attempt ${queueItem.attempts + 1}/${queueItem.maxAttempts})`);
                        
                        setTimeout(() => {
                            // Reset timeout for retry
                            queueItem.timeout = setTimeout(() => {
                                const index = this.requestQueue.findIndex(item => item.id === queueItem.id);
                                if (index > -1) {
                                    this.requestQueue.splice(index, 1);
                                }
                                queueItem.reject(new Error(`Request timeout after retry attempt ${queueItem.attempts}`));
                            }, this.queueTimeout);
                            
                            // Re-queue for retry
                            this.requestQueue.unshift(queueItem);
                            this.processQueueAsync();
                        }, retryDelay);
                    } else {
                        // Max retries reached or non-retryable error
                        queueItem.reject(error);
                        this.failedRequests++;
                    }
                }
                
            } finally {
                this.activeRequests--;
                this.isProcessing = false;
                
                // ✅ FIXED: Continue processing remaining items after small delay
                if (this.requestQueue.length > 0) {
                    setTimeout(() => this.processQueue(), 100);
                }
            }
        }
        
        /**
         * ✅ NEW: Determine if error is retryable
         */
        shouldRetry(error) {
            const retryableErrors = [
                'Network request failed',
                'fetch failed',
                'Failed to fetch',
                'Connection error',
                'HTTP 5', // 500-level errors
                'timeout'
            ];
            
            const errorMessage = error.message || error.toString();
            return retryableErrors.some(retryable => 
                errorMessage.toLowerCase().includes(retryable.toLowerCase())
            );
        }
        
        /**
         * ✅ CRITICAL FIX: getStats() without calling isHealthy() - PREVENTS INFINITE RECURSION
         */
        getStats() {
            return {
                activeRequests: this.activeRequests,
                queueLength: this.requestQueue.length,
                lastRequestTime: this.lastRequestTime,
                successfulRequests: this.successfulRequests,
                failedRequests: this.failedRequests,
                successRate: this.successfulRequests / Math.max(1, this.successfulRequests + this.failedRequests),
                queueTimeout: this.queueTimeout,
                maxConcurrent: this.maxConcurrent,
                minInterval: this.minInterval,
                avgWaitTime: this.calculateAverageWaitTime()
            };
        }
        
        /**
         * ✅ CRITICAL FIX: isHealthy() without calling getStats() - PREVENTS INFINITE RECURSION
         */
        isHealthy() {
            // Direct property access - NO METHOD CALLS to avoid recursion
            const queueLengthOk = this.requestQueue.length < 20;
            const successRateOk = this.successfulRequests / Math.max(1, this.successfulRequests + this.failedRequests) > 0.6;
            const activeRequestsOk = this.activeRequests <= this.maxConcurrent;
            const noStaleRequests = !this.hasStaleRequests();
            
            return queueLengthOk && successRateOk && activeRequestsOk && noStaleRequests;
        }
        
        /**
         * ✅ NEW: Check for stale requests that might be stuck
         */
        hasStaleRequests() {
            const now = Date.now();
            const staleThreshold = this.queueTimeout * 0.8; // 80% of timeout
            
            return this.requestQueue.some(item => 
                now - item.timestamp > staleThreshold
            );
        }
        
        /**
         * ✅ NEW: Calculate average wait time
         */
        calculateAverageWaitTime() {
            if (this.requestQueue.length === 0) return 0;
            
            const now = Date.now();
            const totalWaitTime = this.requestQueue.reduce((sum, item) => 
                sum + (now - item.timestamp), 0
            );
            
            return Math.round(totalWaitTime / this.requestQueue.length);
        }
        
        /**
         * ✅ ENHANCED: Emergency queue clearing with better cleanup
         */
        clearQueue(reason = 'Manual clear') {
            console.warn(`🚨 Clearing request queue: ${reason}`);
            
            const clearedCount = this.requestQueue.length;
            
            this.requestQueue.forEach(item => {
                if (item.timeout) {
                    clearTimeout(item.timeout);
                }
                item.reject(new Error(`Queue cleared: ${reason}`));
            });
            
            this.requestQueue = [];
            this.isProcessing = false;
            
            console.log(`✅ Cleared ${clearedCount} requests, ${this.activeRequests} still active`);
        }
        
        /**
         * ✅ NEW: Health check and auto-recovery
         */
        performHealthCheck() {
            // Get health status without causing recursion
            const healthy = this.isHealthy();
            const queueLength = this.requestQueue.length;
            const successRate = this.successfulRequests / Math.max(1, this.successfulRequests + this.failedRequests);
            const avgWaitTime = this.calculateAverageWaitTime();
            const activeRequests = this.activeRequests;
            
            console.log('🩺 Request Queue Health Check:', {
                healthy: healthy,
                queueLength: queueLength,
                successRate: `${(successRate * 100).toFixed(1)}%`,
                avgWaitTime: `${avgWaitTime}ms`,
                activeRequests: activeRequests
            });
            
            if (!healthy) {
                console.warn('⚠️ Queue unhealthy, attempting recovery...');
                this.performRecovery();
            }
            
            return healthy;
        }
        
        /**
         * ✅ NEW: Auto-recovery procedures
         */
        performRecovery() {
            const now = Date.now();
            
            // Remove stale requests
            const staleRequests = this.requestQueue.filter(item => 
                now - item.timestamp > this.queueTimeout * 0.9
            );
            
            if (staleRequests.length > 0) {
                console.log(`🗑️ Removing ${staleRequests.length} stale requests`);
                staleRequests.forEach(item => {
                    if (item.timeout) clearTimeout(item.timeout);
                    item.reject(new Error('Request too old, removed during recovery'));
                });
                
                this.requestQueue = this.requestQueue.filter(item => 
                    now - item.timestamp <= this.queueTimeout * 0.9
                );
            }
            
            // Force process queue if stuck
            if (this.requestQueue.length > 0 && !this.isProcessing && this.activeRequests < this.maxConcurrent) {
                console.log('🔧 Force-starting queue processing during recovery');
                this.processQueueAsync();
            }
        }
        
        /**
         * ✅ NEW: Emergency reset method
         */
        forceReset() {
            console.warn('🚨 Force resetting RequestQueue');
            this.clearQueue('Force reset');
            this.activeRequests = 0;
            this.failedRequests = 0;
            this.successfulRequests = 0;
            this.lastRequestTime = 0;
            console.log('✅ RequestQueue force reset complete');
        }
    }
    
    // ============================================================================
    // ✅ INITIALIZE REQUEST QUEUE WITH FIXED CONFIGURATION
    // ============================================================================
    
    const requestQueue = new RequestQueue(
        ENHANCED_CONFIG.REQUEST_THROTTLING.maxConcurrent,
        ENHANCED_CONFIG.REQUEST_THROTTLING.minInterval
    );
    
    // ============================================================================
    // ✅ ENHANCED FETCH WRAPPER WITH REQUEST QUEUING
    // ============================================================================
    
    async function enhancedFetch(url, options = {}) {
        const priority = options.priority || 'normal';
        delete options.priority; // Remove custom option before fetch
        
        return requestQueue.enqueue(async () => {
            console.log(`🌐 Making ${priority} priority request to: ${url}`);
            
            try {
                const response = await fetch(url, {
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                        ...options.headers
                    },
                    ...options
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log(`✅ Request successful: ${url} (${response.status})`);
                return data;
                
            } catch (error) {
                console.error(`❌ Request failed: ${url}`, error);
                throw error;
            }
        }, priority);
    }
    
    // ============================================================================
    // ✅ ENHANCED TAB SWITCHING WITH MODULE LOADING
    // ============================================================================
    
    function showTab(tab) {
        console.log('🔄 Switching to tab:', tab);
        
        try {
            currentTab = tab;
            
            // ✅ CRITICAL: Validate arrays before any tab operations
            validateManagedServers();
            
            // Update navigation
            document.querySelectorAll('.nav-tab').forEach(t => {
                if (t && t.classList) {
                    t.classList.remove('active');
                }
            });
            
            const navTab = document.getElementById(tab + '-tab');
            if (navTab && navTab.classList) {
                navTab.classList.add('active');
            }
            
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                if (view && view.classList) {
                    view.classList.add('hidden');
                }
            });
            
            // Show target view
            let targetView = document.getElementById(tab + '-view');
            if (!targetView) {
                targetView = document.getElementById(tab);
            }
            
            if (targetView && targetView.classList) {
                targetView.classList.remove('hidden');
                console.log('✅ Showing view:', targetView.id);
            } else {
                console.error('❌ No view found for tab:', tab);
                createPlaceholderView(tab);
                return;
            }
            
            // ✅ ENHANCED: Load tab-specific modules with better error handling
            loadTabModule(tab);
            
            console.log('✅ Tab switch complete:', tab);
            
        } catch (error) {
            console.error('❌ showTab error:', error);
            // Try to fix arrays if tab switching fails
            fixManagedServers();
        }
    }
    
    /**
     * ✅ ENHANCED: Module loading with availability checking and array protection
     */
    async function loadTabModule(tab) {
        console.log(`📦 Loading module for tab: ${tab}`);
        
        try {
            // ✅ CRITICAL: Ensure arrays are valid before module loading
            validateManagedServers();
            
            switch(tab) {
                case 'dashboard':
                    safeCall('loadDashboard');
                    break;
                    
                case 'server-manager':
                    // ✅ CRITICAL: Extra protection for server manager
                    console.log('🔧 Loading Server Manager with array protection...');
                    await ensureServerManagerLoaded();
                    safeCall('loadServerManager');
                    
                    // Auto-load servers if not loaded
                    setTimeout(() => {
                        if (managedServers.length === 0) {
                            console.log('📡 Auto-loading servers for Server Manager...');
                            loadManagedServers().catch(error => {
                                console.warn('⚠️ Auto-load servers failed:', error);
                            });
                        }
                    }, 500);
                    break;
                    
                case 'console':
                    safeCall('initializeConsole');
                    break;
                    
                case 'logs':
                    // ✅ CRITICAL: Ensure servers loaded for logs module
                    validateManagedServers();
                    safeCall('loadLogs');
                    break;
                    
                case 'server-health':
                    // ✅ CRITICAL: Ensure servers loaded for health monitoring
                    validateManagedServers();
                    safeCall('loadServerHealth');
                    break;
                    
                case 'events':
                    safeCall('loadEvents');
                    break;
                    
                case 'economy':
                    safeCall('loadEconomy');
                    break;
                    
                case 'gambling':
                    safeCall('loadGambling');
                    break;
                    
                case 'clans':
                    safeCall('loadClans');
                    break;
                    
                case 'user-management':
                case 'users':
                    safeCall('loadUserManagement');
                    break;
                    
                default:
                    console.log(`ℹ️ No specific module loader for tab: ${tab}`);
            }
        } catch (error) {
            console.error(`❌ Error loading module for ${tab}:`, error);
            
            // Try to recover arrays if module loading fails
            if (error.message.includes('find is not a function') || 
                error.message.includes('some is not a function')) {
                console.log('🔧 Array method error detected - fixing...');
                fixManagedServers();
            }
        }
    }
    
    /**
     * ✅ NEW: Ensure Server Manager module is loaded
     */
    async function ensureServerManagerLoaded() {
        const requiredFunctions = ['addNewServer', 'loadServerManager', 'clearServerForm'];
        const missingFunctions = requiredFunctions.filter(func => typeof window[func] !== 'function');
        
        if (missingFunctions.length > 0) {
            console.log(`⚠️ Missing server manager functions: ${missingFunctions.join(', ')}`);
            console.log('🔧 Server manager functions will use template fallbacks');
        } else {
            console.log('✅ All server manager functions available');
        }
        
        // Ensure arrays are ready
        validateManagedServers();
    }
    
    /**
     * ✅ ENHANCED: Safe function caller with better error handling
     */
    function safeCall(functionName, ...args) {
        try {
            if (typeof window[functionName] === 'function') {
                console.log(`🔧 Calling ${functionName}`);
                return window[functionName](...args);
            } else {
                console.warn(`⚠️ Function ${functionName} not available`);
                return null;
            }
        } catch (error) {
            console.error(`❌ Error calling ${functionName}:`, error);
            
            // If it's an array method error, try to fix it
            if (error.message.includes('is not a function') && 
                (error.message.includes('find') || error.message.includes('some'))) {
                console.log('🔧 Array method error in function call - fixing arrays...');
                fixManagedServers();
            }
            
            return null;
        }
    }
    
    /**
     * ✅ ENHANCED: Status display with better formatting
     */
    function showStatus(message, type = 'info') {
        console.log(`📢 Status (${type}): ${message}`);
        
        // Try to find status display elements
        const statusSelectors = ['#statusDisplay', '#globalStatus', '.status-message'];
        let statusEl = null;
        
        for (const selector of statusSelectors) {
            statusEl = document.querySelector(selector);
            if (statusEl) break;
        }
        
        if (statusEl) {
            const colors = {
                'error': 'text-red-400',
                'success': 'text-green-400',
                'warning': 'text-yellow-400',
                'info': 'text-blue-400'
            };
            
            statusEl.innerHTML = `<span class="${colors[type] || 'text-gray-400'}">${message}</span>`;
            
            // Auto-clear after 5 seconds for non-error messages
            if (type !== 'error') {
                setTimeout(() => {
                    if (statusEl) statusEl.innerHTML = '';
                }, 5000);
            }
        }
    }
    
    /**
     * ✅ UTILITY FUNCTIONS
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function getMessageTypeIcon(type) {
        const icons = {
            'info': 'ℹ️',
            'success': '✅',
            'error': '❌',
            'warning': '⚠️',
            'debug': '🔧'
        };
        return icons[type] || 'ℹ️';
    }
    
    /**
     * ✅ PLACEHOLDER VIEW CREATOR
     */
    function createPlaceholderView(tabId) {
        console.log('🔧 Creating placeholder view for:', tabId);
        
        const container = document.querySelector('.main-content') || document.querySelector('main') || document.body;
        
        const placeholderView = document.createElement('div');
        placeholderView.id = tabId + '-view';
        placeholderView.className = 'view bg-gray-800 p-6 rounded-lg';
        
        const title = tabId.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
        
        placeholderView.innerHTML = `
            <h2 class="text-2xl font-bold mb-4">🔧 ${title}</h2>
            <p class="text-gray-400 mb-4">This section is currently being loaded...</p>
            <div class="text-sm text-gray-500">
                <p>If this message persists, please try refreshing the page.</p>
            </div>
        `;
        
        container.appendChild(placeholderView);
    }
    
    /**
     * ✅ DEBUG AND MONITORING FUNCTIONS - FIXED TO AVOID RECURSION
     */
    function getEnhancementStats() {
        // Get stats safely without triggering recursion
        const queueStats = {
            activeRequests: requestQueue.activeRequests,
            queueLength: requestQueue.requestQueue.length,
            successfulRequests: requestQueue.successfulRequests,
            failedRequests: requestQueue.failedRequests,
            successRate: requestQueue.successfulRequests / Math.max(1, requestQueue.successfulRequests + requestQueue.failedRequests),
            avgWaitTime: requestQueue.calculateAverageWaitTime()
        };
        
        return {
            config: ENHANCED_CONFIG,
            requestQueue: queueStats,
            currentTab: currentTab,
            timestamp: new Date().toISOString(),
            performance: {
                queueHealthy: requestQueue.isHealthy(),
                avgWaitTime: queueStats.avgWaitTime,
                hasStaleRequests: requestQueue.hasStaleRequests()
            },
            arrayStatus: {
                managedServersType: typeof window.managedServers,
                managedServersIsArray: Array.isArray(window.managedServers),
                managedServersLength: window.managedServers ? window.managedServers.length : 0,
                arrayInitialized: arrayInitialized
            }
        };
    }
    
    function debugEnhancements() {
        console.log('🔍 ENHANCEMENT DEBUG INFO (COMPLETE FIXED VERSION):');
        console.log('=================================================');
        
        const stats = getEnhancementStats();
        
        console.log('Configuration:');
        Object.entries(ENHANCED_CONFIG.POLLING_INTERVALS).forEach(([key, value]) => {
            console.log(`  - ${key}: ${value/1000}s`);
        });
        
        console.log(`Queue timeout: ${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s (FIXED from 90s)`);
        
        console.log('Request Queue Stats:');
        console.log(`  - Active: ${stats.requestQueue.activeRequests}/${ENHANCED_CONFIG.REQUEST_THROTTLING.maxConcurrent}`);
        console.log(`  - Queued: ${stats.requestQueue.queueLength}`);
        console.log(`  - Success Rate: ${(stats.requestQueue.successRate * 100).toFixed(1)}%`);
        console.log(`  - Avg Wait: ${stats.requestQueue.avgWaitTime}ms`);
        console.log(`  - Healthy: ${stats.performance.queueHealthy}`);
        
        console.log('Array Status:');
        console.log(`  - managedServers type: ${stats.arrayStatus.managedServersType}`);
        console.log(`  - managedServers isArray: ${stats.arrayStatus.managedServersIsArray}`);
        console.log(`  - managedServers length: ${stats.arrayStatus.managedServersLength}`);
        console.log(`  - arrayInitialized: ${stats.arrayStatus.arrayInitialized}`);
        
        console.log('Current State:');
        console.log(`  - Tab: ${stats.currentTab}`);
        console.log(`  - Managed Servers: ${managedServers.length}`);
        
        console.log('Key Improvements:');
        console.log('  - ✅ CRITICAL: Fixed managedServers array initialization');
        console.log('  - ✅ CRITICAL: Added array validation and protection');
        console.log('  - ✅ CRITICAL: Added emergency recovery functions');
        console.log('  - ✅ FIXED: 2-minute timeout (was 90s)');
        console.log('  - ✅ FIXED: Proper timeout clearing');
        console.log('  - ✅ FIXED: Retry logic with exponential backoff');
        console.log('  - ✅ FIXED: Better health monitoring');
        console.log('  - ✅ FIXED: Auto-recovery procedures');
        console.log('  - ✅ CRITICAL: Eliminated infinite recursion');
        
        if (!stats.performance.queueHealthy) {
            console.warn('⚠️ Request queue unhealthy - running recovery...');
            requestQueue.performRecovery();
        }
        
        if (!stats.arrayStatus.managedServersIsArray) {
            console.error('❌ CRITICAL: managedServers array corrupted - fixing...');
            fixManagedServers();
        }
    }
    
    // ============================================================================
    // ✅ CRITICAL: GLOBAL FUNCTION EXPOSURE WITH ARRAY PROTECTION
    // ============================================================================
    
    // Core functions
    window.showTab = showTab;
    window.loadTabModule = loadTabModule;
    window.safeCall = safeCall;
    window.showStatus = showStatus;
    window.escapeHtml = escapeHtml;
    window.getMessageTypeIcon = getMessageTypeIcon;
    window.createPlaceholderView = createPlaceholderView;
    
    // Enhanced functions
    window.enhancedFetch = enhancedFetch;
    window.requestQueue = requestQueue;
    window.getEnhancementStats = getEnhancementStats;
    window.debugEnhancements = debugEnhancements;
    window.ENHANCED_CONFIG = ENHANCED_CONFIG;
    
    // ✅ CRITICAL: Array protection functions
    window.validateManagedServers = validateManagedServers;
    window.fixManagedServers = fixManagedServers;
    window.safeArrayOperation = safeArrayOperation;
    window.loadManagedServers = loadManagedServers;
    
    // ✅ Emergency functions
    window.fixRequestQueue = () => {
        requestQueue.forceReset();
        console.log('✅ RequestQueue manually reset');
    };
    
    window.emergencyFix = () => {
        console.log('🚑 Running emergency fix...');
        fixManagedServers();
        requestQueue.forceReset();
        console.log('✅ Emergency fix complete');
    };
    
    // ✅ CRITICAL: Global variables with proper initialization
    window.currentTab = currentTab;
    window.servers = servers;
    window.managedServers = managedServers;    // ✅ CRITICAL: Properly initialized array
    window.selectedServers = selectedServers;
    window.wsConnection = wsConnection;
    window.isDemo = isDemo;
    window.connectionStatus = connectionStatus;
    window.serverFilter = serverFilter;
    window.messageTypeFilter = messageTypeFilter;
    window.autoScroll = autoScroll;
    window.websocketsAvailable = websocketsAvailable;
    
    // ============================================================================
    // ✅ INITIALIZATION WITH COMPREHENSIVE PROTECTION
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('🚀 GUST Bot Enhanced - Core Module Initializing (COMPLETE FIXED VERSION)');
        
        // ✅ CRITICAL: Mark arrays as initialized
        arrayInitialized = true;
        
        // ✅ CRITICAL: Initial array validation
        console.log('🔧 Running initial array validation...');
        validateManagedServers();
        
        // ✅ CRITICAL: Set up global error handler for array issues
        window.addEventListener('error', function(event) {
            if (event.error && event.error.message) {
                const errorMsg = event.error.message;
                if (errorMsg.includes('.find is not a function') || 
                    errorMsg.includes('.some is not a function') ||
                    errorMsg.includes('.filter is not a function')) {
                    console.error('🚨 Array method error caught - auto-fixing:', errorMsg);
                    fixManagedServers();
                }
            }
        });
        
        // Initialize with default tab
        setTimeout(() => {
            if (window.location.hash) {
                const tab = window.location.hash.substring(1);
                showTab(tab);
            } else {
                showTab('dashboard');
            }
        }, 500);
        
        // Set up hash change handling
        window.addEventListener('hashchange', function() {
            const tab = window.location.hash.substring(1);
            if (tab && typeof showTab === 'function') {
                showTab(tab);
            }
        });
        
        // ✅ ENHANCED: Health monitoring with auto-recovery - SAFE FROM RECURSION
        setInterval(() => {
            try {
                // Validate arrays periodically
                if (!validateManagedServers()) {
                    console.warn('⚠️ Array validation failed during health check');
                }
                
                // Check request queue health
                if (!requestQueue.performHealthCheck()) {
                    console.warn('⚠️ Request queue health check failed, recovery attempted');
                }
            } catch (error) {
                console.error('❌ Health check error:', error);
                // Emergency reset if health check fails
                fixManagedServers();
                requestQueue.forceReset();
            }
        }, 60000); // Check every minute
        
        // ✅ NEW: Performance monitoring - SAFE FROM RECURSION
        setInterval(() => {
            try {
                const queueLength = requestQueue.requestQueue.length;
                const avgWaitTime = requestQueue.calculateAverageWaitTime();
                
                if (queueLength > 10) {
                    console.warn(`⚠️ Request queue getting long: ${queueLength} items`);
                }
                if (avgWaitTime > 10000) {
                    console.warn(`⚠️ High average wait time: ${avgWaitTime}ms`);
                }
                
                // Periodic array validation
                if (!Array.isArray(window.managedServers)) {
                    console.warn('⚠️ managedServers corrupted - auto-fixing');
                    fixManagedServers();
                }
            } catch (error) {
                console.error('❌ Performance monitoring error:', error);
            }
        }, 30000); // Check every 30 seconds
        
        // ✅ CRITICAL: Auto-load servers after initialization
        setTimeout(() => {
            console.log('📡 Auto-loading servers after initialization...');
            loadManagedServers().then(servers => {
                console.log(`✅ Auto-loaded ${servers.length} servers successfully`);
            }).catch(error => {
                console.warn('⚠️ Auto-load servers failed (this is normal for new installations):', error);
                // Ensure arrays are still valid even if loading fails
                validateManagedServers();
            });
        }, 2000);
        
        console.log('✅ Core initialization complete with CRITICAL array protection fixes');
        console.log('🔧 Key improvements active:');
        console.log('  - ✅ CRITICAL: managedServers properly initialized as array');
        console.log('  - ✅ CRITICAL: Array validation and protection functions');
        console.log('  - ✅ CRITICAL: Emergency recovery functions available');
        console.log('  - 2-minute request timeout (eliminates 90s timeouts)');
        console.log('  - Proper timeout clearing prevents false timeouts');
        console.log('  - Retry logic with exponential backoff');
        console.log('  - Auto health monitoring and recovery');
        console.log('  - Enhanced error handling and logging');
        console.log('  - ✅ CRITICAL: Eliminated infinite recursion bug');
        
        // Show debug info after 3 seconds
        setTimeout(() => {
            debugEnhancements();
        }, 3000);
        
        console.log('🎯 Expected result: No more "TypeError: .find/.some is not a function" errors');
        console.log('🎯 Expected result: No more "Request queue timeout after 90s" errors');
        console.log('🎯 Expected result: No more "Maximum call stack size exceeded" errors');
        console.log('🎯 Expected result: managedServers always working as proper array');
    });
    
    console.log('✅ Enhanced Main.js Loaded with COMPLETE Array Protection and Request Queue Fixes');
    console.log('🚀 Ready for tab switching and server operations with ZERO array errors');

</script>