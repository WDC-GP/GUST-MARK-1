<!-- ============================================================================
     GUST Bot Enhanced - Core JavaScript (COMPLETE FIXED VERSION)
     ============================================================================
     âœ… FIXED: Request queue timeout increased to 2 minutes (was 90s)
     âœ… FIXED: Proper timeout clearing when requests start processing
     âœ… FIXED: Enhanced module loading with availability checks
     âœ… FIXED: Better error handling and recovery mechanisms
     âœ… FIXED: Non-blocking queue processing with retry logic
     âœ… CRITICAL FIX: Removed circular dependency between getStats() and isHealthy()
     ============================================================================ -->

<script>
    // ============================================================================
    // ENHANCED CONFIGURATION WITH FIXED TIMEOUTS
    // ============================================================================
    
    const ENHANCED_CONFIG = {
        POLLING_INTERVALS: {
            servers: 15000,          // 15s (more conservative)
            player_count: 30000,     // 30s (less frequent)
            console: 20000,          // 20s (reduced load)
            server_health: 120000    // 2min (background only)
        },
        
        REQUEST_THROTTLING: {
            maxConcurrent: 2,        // Reduced concurrency
            minInterval: 1000,       // 1s between requests
            queueTimeout: 120000     // âœ… CRITICAL: 2 minutes (was 90s)
        },
        
        AUTH_RECOVERY: {
            maxFailures: 5,          // More patient
            retryDelay: 3000,        // 3s between retries
            exponentialBackoff: true,
            redirectAfterFailures: 8  // Very patient
        }
    };
    
    // ============================================================================
    // GLOBAL VARIABLES
    // ============================================================================
    
    let currentTab = 'dashboard';
    let managedServers = [];
    let selectedServers = new Set();
    let servers = [];
    let wsConnection = null;
    let isDemo = false;
    let connectionStatus = {};
    let serverFilter = '';
    let messageTypeFilter = 'all';
    let autoScroll = true;
    let websocketsAvailable = true;

    // ============================================================================
    // âœ… FIXED REQUEST QUEUE CLASS WITH PROPER TIMEOUT HANDLING
    // ============================================================================
    
    class RequestQueue {
        constructor(maxConcurrent = 2, minInterval = 1000) {
            this.maxConcurrent = maxConcurrent;
            this.minInterval = minInterval;
            this.activeRequests = 0;
            this.requestQueue = [];
            this.lastRequestTime = 0;
            this.isProcessing = false;
            this.failedRequests = 0;
            this.successfulRequests = 0;
            this.queueTimeout = ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout;
            
            console.log(`âœ… Fixed RequestQueue initialized: max ${maxConcurrent} concurrent, ${minInterval}ms interval, ${this.queueTimeout/1000}s timeout`);
        }
        
        /**
         * âœ… CRITICAL FIX: Improved enqueue with proper timeout management
         */
        async enqueue(requestFunction, priority = 'normal') {
            return new Promise((resolve, reject) => {
                const queueItem = {
                    requestFunction,
                    resolve,
                    reject,
                    priority,
                    timestamp: Date.now(),
                    timeout: null,
                    id: Math.random().toString(36).substr(2, 9),
                    attempts: 0,
                    maxAttempts: 3
                };
                
                // âœ… FIXED: Set timeout with proper cleanup tracking
                queueItem.timeout = setTimeout(() => {
                    console.warn(`â° Request timeout: ${queueItem.id} after ${this.queueTimeout/1000}s`);
                    
                    // Remove from queue if still there
                    const index = this.requestQueue.findIndex(item => item.id === queueItem.id);
                    if (index > -1) {
                        this.requestQueue.splice(index, 1);
                        console.log(`ðŸ—‘ï¸ Removed timed-out request from queue: ${queueItem.id}`);
                    }
                    
                    this.failedRequests++;
                    reject(new Error(`Request timeout after ${this.queueTimeout/1000}s - server may be busy or request too complex`));
                }, this.queueTimeout);
                
                // Insert based on priority
                if (priority === 'high') {
                    this.requestQueue.unshift(queueItem);
                } else {
                    this.requestQueue.push(queueItem);
                }
                
                console.log(`ðŸ“ Queued request ${queueItem.id} (priority: ${priority}, queue: ${this.requestQueue.length})`);
                
                // Start processing (non-blocking)
                this.processQueueAsync();
            });
        }
        
        /**
         * âœ… FIXED: Non-blocking queue processing trigger
         */
        processQueueAsync() {
            if (!this.isProcessing && this.requestQueue.length > 0) {
                setTimeout(() => this.processQueue(), 10);
            }
        }
        
        /**
         * âœ… CRITICAL FIX: Improved queue processing with proper timeout clearing
         */
        async processQueue() {
            // Prevent multiple simultaneous processing
            if (this.isProcessing) {
                return;
            }
            
            // No items to process
            if (this.requestQueue.length === 0) {
                return;
            }
            
            // Too many active requests - wait and retry
            if (this.activeRequests >= this.maxConcurrent) {
                console.log(`â¸ï¸ Queue paused: ${this.activeRequests}/${this.maxConcurrent} active requests`);
                setTimeout(() => this.processQueue(), 1000);
                return;
            }
            
            this.isProcessing = true;
            
            try {
                // Check minimum interval between requests
                const now = Date.now();
                const timeSinceLastRequest = now - this.lastRequestTime;
                if (timeSinceLastRequest < this.minInterval) {
                    const waitTime = this.minInterval - timeSinceLastRequest;
                    console.log(`â±ï¸ Waiting ${waitTime}ms before next request (rate limiting)`);
                    setTimeout(() => {
                        this.isProcessing = false;
                        this.processQueue();
                    }, waitTime);
                    return;
                }
                
                // Get next request
                const queueItem = this.requestQueue.shift();
                if (!queueItem) {
                    this.isProcessing = false;
                    return;
                }
                
                // âœ… CRITICAL FIX: Clear timeout IMMEDIATELY when processing starts
                if (queueItem.timeout) {
                    clearTimeout(queueItem.timeout);
                    queueItem.timeout = null;
                    console.log(`âœ… Cleared timeout for processing request: ${queueItem.id}`);
                }
                
                this.activeRequests++;
                this.lastRequestTime = now;
                
                console.log(`ðŸ”„ Processing request ${queueItem.id} (${this.activeRequests}/${this.maxConcurrent} active, ${this.requestQueue.length} queued)`);
                
                try {
                    // Execute the actual request
                    const result = await queueItem.requestFunction();
                    queueItem.resolve(result);
                    this.successfulRequests++;
                    console.log(`âœ… Request ${queueItem.id} completed successfully`);
                    
                } catch (error) {
                    console.error(`âŒ Request ${queueItem.id} failed (attempt ${queueItem.attempts + 1}):`, error);
                    
                    // âœ… ENHANCED: Retry logic with exponential backoff
                    queueItem.attempts++;
                    if (queueItem.attempts < queueItem.maxAttempts && this.shouldRetry(error)) {
                        const retryDelay = 2000 * Math.pow(2, queueItem.attempts - 1); // Exponential backoff
                        console.log(`ðŸ”„ Retrying request ${queueItem.id} in ${retryDelay}ms (attempt ${queueItem.attempts + 1}/${queueItem.maxAttempts})`);
                        
                        setTimeout(() => {
                            // Reset timeout for retry
                            queueItem.timeout = setTimeout(() => {
                                const index = this.requestQueue.findIndex(item => item.id === queueItem.id);
                                if (index > -1) {
                                    this.requestQueue.splice(index, 1);
                                }
                                queueItem.reject(new Error(`Request timeout after retry attempt ${queueItem.attempts}`));
                            }, this.queueTimeout);
                            
                            // Re-queue for retry
                            this.requestQueue.unshift(queueItem);
                            this.processQueueAsync();
                        }, retryDelay);
                    } else {
                        // Max retries reached or non-retryable error
                        queueItem.reject(error);
                        this.failedRequests++;
                    }
                }
                
            } finally {
                this.activeRequests--;
                this.isProcessing = false;
                
                // âœ… FIXED: Continue processing remaining items after small delay
                if (this.requestQueue.length > 0) {
                    setTimeout(() => this.processQueue(), 100);
                }
            }
        }
        
        /**
         * âœ… NEW: Determine if error is retryable
         */
        shouldRetry(error) {
            const retryableErrors = [
                'Network request failed',
                'fetch failed',
                'Failed to fetch',
                'Connection error',
                'HTTP 5', // 500-level errors
                'timeout'
            ];
            
            const errorMessage = error.message || error.toString();
            return retryableErrors.some(retryable => 
                errorMessage.toLowerCase().includes(retryable.toLowerCase())
            );
        }
        
        /**
         * âœ… CRITICAL FIX: getStats() without calling isHealthy() - PREVENTS INFINITE RECURSION
         */
        getStats() {
            return {
                activeRequests: this.activeRequests,
                queueLength: this.requestQueue.length,
                lastRequestTime: this.lastRequestTime,
                successfulRequests: this.successfulRequests,
                failedRequests: this.failedRequests,
                successRate: this.successfulRequests / Math.max(1, this.successfulRequests + this.failedRequests),
                // âœ… REMOVED: isHealthy: this.isHealthy(), // This was causing infinite recursion
                queueTimeout: this.queueTimeout,
                maxConcurrent: this.maxConcurrent,
                minInterval: this.minInterval,
                avgWaitTime: this.calculateAverageWaitTime()
            };
        }
        
        /**
         * âœ… CRITICAL FIX: isHealthy() without calling getStats() - PREVENTS INFINITE RECURSION
         */
        isHealthy() {
            // Direct property access - NO METHOD CALLS to avoid recursion
            const queueLengthOk = this.requestQueue.length < 20;
            const successRateOk = this.successfulRequests / Math.max(1, this.successfulRequests + this.failedRequests) > 0.6;
            const activeRequestsOk = this.activeRequests <= this.maxConcurrent;
            const noStaleRequests = !this.hasStaleRequests();
            
            return queueLengthOk && successRateOk && activeRequestsOk && noStaleRequests;
        }
        
        /**
         * âœ… NEW: Check for stale requests that might be stuck
         */
        hasStaleRequests() {
            const now = Date.now();
            const staleThreshold = this.queueTimeout * 0.8; // 80% of timeout
            
            return this.requestQueue.some(item => 
                now - item.timestamp > staleThreshold
            );
        }
        
        /**
         * âœ… NEW: Calculate average wait time
         */
        calculateAverageWaitTime() {
            if (this.requestQueue.length === 0) return 0;
            
            const now = Date.now();
            const totalWaitTime = this.requestQueue.reduce((sum, item) => 
                sum + (now - item.timestamp), 0
            );
            
            return Math.round(totalWaitTime / this.requestQueue.length);
        }
        
        /**
         * âœ… ENHANCED: Emergency queue clearing with better cleanup
         */
        clearQueue(reason = 'Manual clear') {
            console.warn(`ðŸš¨ Clearing request queue: ${reason}`);
            
            const clearedCount = this.requestQueue.length;
            
            this.requestQueue.forEach(item => {
                if (item.timeout) {
                    clearTimeout(item.timeout);
                }
                item.reject(new Error(`Queue cleared: ${reason}`));
            });
            
            this.requestQueue = [];
            this.isProcessing = false;
            
            console.log(`âœ… Cleared ${clearedCount} requests, ${this.activeRequests} still active`);
        }
        
        /**
         * âœ… NEW: Health check and auto-recovery
         */
        performHealthCheck() {
            // Get health status without causing recursion
            const healthy = this.isHealthy();
            const queueLength = this.requestQueue.length;
            const successRate = this.successfulRequests / Math.max(1, this.successfulRequests + this.failedRequests);
            const avgWaitTime = this.calculateAverageWaitTime();
            const activeRequests = this.activeRequests;
            
            console.log('ðŸ¥ Request Queue Health Check:', {
                healthy: healthy,
                queueLength: queueLength,
                successRate: `${(successRate * 100).toFixed(1)}%`,
                avgWaitTime: `${avgWaitTime}ms`,
                activeRequests: activeRequests
            });
            
            if (!healthy) {
                console.warn('âš ï¸ Queue unhealthy, attempting recovery...');
                this.performRecovery();
            }
            
            return healthy;
        }
        
        /**
         * âœ… NEW: Auto-recovery procedures
         */
        performRecovery() {
            const now = Date.now();
            
            // Remove stale requests
            const staleRequests = this.requestQueue.filter(item => 
                now - item.timestamp > this.queueTimeout * 0.9
            );
            
            if (staleRequests.length > 0) {
                console.log(`ðŸ—‘ï¸ Removing ${staleRequests.length} stale requests`);
                staleRequests.forEach(item => {
                    if (item.timeout) clearTimeout(item.timeout);
                    item.reject(new Error('Request too old, removed during recovery'));
                });
                
                this.requestQueue = this.requestQueue.filter(item => 
                    now - item.timestamp <= this.queueTimeout * 0.9
                );
            }
            
            // Force process queue if stuck
            if (this.requestQueue.length > 0 && !this.isProcessing && this.activeRequests < this.maxConcurrent) {
                console.log('ðŸ”§ Force-starting queue processing during recovery');
                this.processQueueAsync();
            }
        }
        
        /**
         * âœ… NEW: Emergency reset method
         */
        forceReset() {
            console.warn('ðŸš¨ Force resetting RequestQueue');
            this.clearQueue('Force reset');
            this.activeRequests = 0;
            this.failedRequests = 0;
            this.successfulRequests = 0;
            this.lastRequestTime = 0;
            console.log('âœ… RequestQueue force reset complete');
        }
    }
    
    // ============================================================================
    // âœ… INITIALIZE REQUEST QUEUE WITH FIXED CONFIGURATION
    // ============================================================================
    
    const requestQueue = new RequestQueue(
        ENHANCED_CONFIG.REQUEST_THROTTLING.maxConcurrent,
        ENHANCED_CONFIG.REQUEST_THROTTLING.minInterval
    );
    
    // ============================================================================
    // âœ… ENHANCED FETCH WRAPPER WITH REQUEST QUEUING
    // ============================================================================
    
    async function enhancedFetch(url, options = {}) {
        const priority = options.priority || 'normal';
        delete options.priority; // Remove custom option before fetch
        
        return requestQueue.enqueue(async () => {
            console.log(`ðŸŒ Making ${priority} priority request to: ${url}`);
            
            try {
                const response = await fetch(url, {
                    credentials: 'same-origin',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                        ...options.headers
                    },
                    ...options
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log(`âœ… Request successful: ${url} (${response.status})`);
                return data;
                
            } catch (error) {
                console.error(`âŒ Request failed: ${url}`, error);
                throw error;
            }
        }, priority);
    }
    
    // ============================================================================
    // âœ… ENHANCED TAB SWITCHING WITH MODULE LOADING
    // ============================================================================
    
    function showTab(tab) {
        console.log('ðŸ”„ Switching to tab:', tab);
        
        try {
            currentTab = tab;
            
            // Update navigation
            document.querySelectorAll('.nav-tab').forEach(t => {
                if (t && t.classList) {
                    t.classList.remove('active');
                }
            });
            
            const navTab = document.getElementById(tab + '-tab');
            if (navTab && navTab.classList) {
                navTab.classList.add('active');
            }
            
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                if (view && view.classList) {
                    view.classList.add('hidden');
                }
            });
            
            // Show target view
            let targetView = document.getElementById(tab + '-view');
            if (!targetView) {
                targetView = document.getElementById(tab);
            }
            
            if (targetView && targetView.classList) {
                targetView.classList.remove('hidden');
                console.log('âœ… Showing view:', targetView.id);
            } else {
                console.error('âŒ No view found for tab:', tab);
                createPlaceholderView(tab);
                return;
            }
            
            // âœ… ENHANCED: Load tab-specific modules with better error handling
            loadTabModule(tab);
            
            console.log('âœ… Tab switch complete:', tab);
            
        } catch (error) {
            console.error('âŒ showTab error:', error);
        }
    }
    
    /**
     * âœ… ENHANCED: Module loading with availability checking
     */
    async function loadTabModule(tab) {
        console.log(`ðŸ“¦ Loading module for tab: ${tab}`);
        
        try {
            switch(tab) {
                case 'dashboard':
                    safeCall('loadDashboard');
                    break;
                    
                case 'server-manager':
                    // Ensure server manager functions are available
                    await ensureServerManagerLoaded();
                    safeCall('loadServerManager');
                    break;
                    
                case 'console':
                    safeCall('initializeConsole');
                    break;
                    
                case 'events':
                    safeCall('loadEvents');
                    break;
                    
                case 'economy':
                    safeCall('loadEconomy');
                    break;
                    
                case 'gambling':
                    safeCall('loadGambling');
                    break;
                    
                case 'clans':
                    safeCall('loadClans');
                    break;
                    
                case 'user-management':
                case 'users':
                    safeCall('loadUserManagement');
                    break;
                    
                case 'logs':
                    safeCall('loadLogs');
                    break;
                    
                case 'server-health':
                    safeCall('loadServerHealth');
                    break;
                    
                default:
                    console.log(`â„¹ï¸ No specific module loader for tab: ${tab}`);
            }
        } catch (error) {
            console.error(`âŒ Error loading module for ${tab}:`, error);
        }
    }
    
    /**
     * âœ… NEW: Ensure Server Manager module is loaded
     */
    async function ensureServerManagerLoaded() {
        const requiredFunctions = ['addNewServer', 'loadServerManager', 'clearServerForm'];
        const missingFunctions = requiredFunctions.filter(func => typeof window[func] !== 'function');
        
        if (missingFunctions.length > 0) {
            console.log(`âš ï¸ Missing server manager functions: ${missingFunctions.join(', ')}`);
            console.log('ðŸ”§ Server manager functions will use template fallbacks');
        } else {
            console.log('âœ… All server manager functions available');
        }
    }
    
    /**
     * âœ… ENHANCED: Safe function caller with better error handling
     */
    function safeCall(functionName, ...args) {
        try {
            if (typeof window[functionName] === 'function') {
                console.log(`ðŸ”§ Calling ${functionName}`);
                return window[functionName](...args);
            } else {
                console.warn(`âš ï¸ Function ${functionName} not available`);
                return null;
            }
        } catch (error) {
            console.error(`âŒ Error calling ${functionName}:`, error);
            return null;
        }
    }
    
    /**
     * âœ… ENHANCED: Status display with better formatting
     */
    function showStatus(message, type = 'info') {
        console.log(`ðŸ“¢ Status (${type}): ${message}`);
        
        // Try to find status display elements
        const statusSelectors = ['#statusDisplay', '#globalStatus', '.status-message'];
        let statusEl = null;
        
        for (const selector of statusSelectors) {
            statusEl = document.querySelector(selector);
            if (statusEl) break;
        }
        
        if (statusEl) {
            const colors = {
                'error': 'text-red-400',
                'success': 'text-green-400',
                'warning': 'text-yellow-400',
                'info': 'text-blue-400'
            };
            
            statusEl.innerHTML = `<span class="${colors[type] || 'text-gray-400'}">${message}</span>`;
            
            // Auto-clear after 5 seconds for non-error messages
            if (type !== 'error') {
                setTimeout(() => {
                    if (statusEl) statusEl.innerHTML = '';
                }, 5000);
            }
        }
    }
    
    /**
     * âœ… UTILITY FUNCTIONS
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function getMessageTypeIcon(type) {
        const icons = {
            'info': 'â„¹ï¸',
            'success': 'âœ…',
            'error': 'âŒ',
            'warning': 'âš ï¸',
            'debug': 'ðŸ”§'
        };
        return icons[type] || 'â„¹ï¸';
    }
    
    /**
     * âœ… PLACEHOLDER VIEW CREATOR
     */
    function createPlaceholderView(tabId) {
        console.log('ðŸ”§ Creating placeholder view for:', tabId);
        
        const container = document.querySelector('.main-content') || document.querySelector('main') || document.body;
        
        const placeholderView = document.createElement('div');
        placeholderView.id = tabId + '-view';
        placeholderView.className = 'view bg-gray-800 p-6 rounded-lg';
        
        const title = tabId.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
        
        placeholderView.innerHTML = `
            <h2 class="text-2xl font-bold mb-4">ðŸ”§ ${title}</h2>
            <p class="text-gray-400 mb-4">This section is currently being loaded...</p>
            <div class="text-sm text-gray-500">
                <p>If this message persists, please try refreshing the page.</p>
            </div>
        `;
        
        container.appendChild(placeholderView);
    }
    
    /**
     * âœ… DEBUG AND MONITORING FUNCTIONS - FIXED TO AVOID RECURSION
     */
    function getEnhancementStats() {
        // Get stats safely without triggering recursion
        const queueStats = {
            activeRequests: requestQueue.activeRequests,
            queueLength: requestQueue.requestQueue.length,
            successfulRequests: requestQueue.successfulRequests,
            failedRequests: requestQueue.failedRequests,
            successRate: requestQueue.successfulRequests / Math.max(1, requestQueue.successfulRequests + requestQueue.failedRequests),
            avgWaitTime: requestQueue.calculateAverageWaitTime()
        };
        
        return {
            config: ENHANCED_CONFIG,
            requestQueue: queueStats,
            currentTab: currentTab,
            timestamp: new Date().toISOString(),
            performance: {
                queueHealthy: requestQueue.isHealthy(),
                avgWaitTime: queueStats.avgWaitTime,
                hasStaleRequests: requestQueue.hasStaleRequests()
            }
        };
    }
    
    function debugEnhancements() {
        console.log('ðŸ” ENHANCEMENT DEBUG INFO (FIXED VERSION):');
        console.log('=============================================');
        
        const stats = getEnhancementStats();
        
        console.log('Configuration:');
        Object.entries(ENHANCED_CONFIG.POLLING_INTERVALS).forEach(([key, value]) => {
            console.log(`  - ${key}: ${value/1000}s`);
        });
        
        console.log(`Queue timeout: ${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s (FIXED from 90s)`);
        
        console.log('Request Queue Stats:');
        console.log(`  - Active: ${stats.requestQueue.activeRequests}/${ENHANCED_CONFIG.REQUEST_THROTTLING.maxConcurrent}`);
        console.log(`  - Queued: ${stats.requestQueue.queueLength}`);
        console.log(`  - Success Rate: ${(stats.requestQueue.successRate * 100).toFixed(1)}%`);
        console.log(`  - Avg Wait: ${stats.requestQueue.avgWaitTime}ms`);
        console.log(`  - Healthy: ${stats.performance.queueHealthy}`);
        
        console.log('Current State:');
        console.log(`  - Tab: ${stats.currentTab}`);
        console.log(`  - Managed Servers: ${managedServers.length}`);
        
        console.log('Key Improvements:');
        console.log('  - âœ… FIXED: 2-minute timeout (was 90s)');
        console.log('  - âœ… FIXED: Proper timeout clearing');
        console.log('  - âœ… FIXED: Retry logic with exponential backoff');
        console.log('  - âœ… FIXED: Better health monitoring');
        console.log('  - âœ… FIXED: Auto-recovery procedures');
        console.log('  - âœ… CRITICAL: Eliminated infinite recursion');
        
        if (!stats.performance.queueHealthy) {
            console.warn('âš ï¸ Request queue unhealthy - running recovery...');
            requestQueue.performRecovery();
        }
    }
    
    // ============================================================================
    // âœ… GLOBAL FUNCTION EXPOSURE
    // ============================================================================
    
    // Core functions
    window.showTab = showTab;
    window.loadTabModule = loadTabModule;
    window.safeCall = safeCall;
    window.showStatus = showStatus;
    window.escapeHtml = escapeHtml;
    window.getMessageTypeIcon = getMessageTypeIcon;
    window.createPlaceholderView = createPlaceholderView;
    
    // Enhanced functions
    window.enhancedFetch = enhancedFetch;
    window.requestQueue = requestQueue;
    window.getEnhancementStats = getEnhancementStats;
    window.debugEnhancements = debugEnhancements;
    window.ENHANCED_CONFIG = ENHANCED_CONFIG;
    
    // âœ… NEW: Emergency functions
    window.fixRequestQueue = () => {
        requestQueue.forceReset();
        console.log('âœ… RequestQueue manually reset');
    };
    
    // Global variables
    window.currentTab = currentTab;
    window.servers = servers;
    window.managedServers = managedServers;
    window.selectedServers = selectedServers;
    window.wsConnection = wsConnection;
    window.isDemo = isDemo;
    window.connectionStatus = connectionStatus;
    window.serverFilter = serverFilter;
    window.messageTypeFilter = messageTypeFilter;
    window.autoScroll = autoScroll;
    window.websocketsAvailable = websocketsAvailable;
    
    // ============================================================================
    // âœ… INITIALIZATION WITH HEALTH MONITORING
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('ðŸš€ GUST Bot Enhanced - Core Module Initializing (FIXED VERSION)');
        
        // Initialize with default tab
        setTimeout(() => {
            if (window.location.hash) {
                const tab = window.location.hash.substring(1);
                showTab(tab);
            } else {
                showTab('dashboard');
            }
        }, 500);
        
        // Set up hash change handling
        window.addEventListener('hashchange', function() {
            const tab = window.location.hash.substring(1);
            if (tab && typeof showTab === 'function') {
                showTab(tab);
            }
        });
        
        // âœ… ENHANCED: Health monitoring with auto-recovery - SAFE FROM RECURSION
        setInterval(() => {
            try {
                if (!requestQueue.performHealthCheck()) {
                    console.warn('âš ï¸ Request queue health check failed, recovery attempted');
                }
            } catch (error) {
                console.error('âŒ Health check error:', error);
                // Emergency reset if health check fails
                requestQueue.forceReset();
            }
        }, 60000); // Check every minute
        
        // âœ… NEW: Performance monitoring - SAFE FROM RECURSION
        setInterval(() => {
            try {
                const queueLength = requestQueue.requestQueue.length;
                const avgWaitTime = requestQueue.calculateAverageWaitTime();
                
                if (queueLength > 10) {
                    console.warn(`âš ï¸ Request queue getting long: ${queueLength} items`);
                }
                if (avgWaitTime > 10000) {
                    console.warn(`âš ï¸ High average wait time: ${avgWaitTime}ms`);
                }
            } catch (error) {
                console.error('âŒ Performance monitoring error:', error);
            }
        }, 30000); // Check every 30 seconds
        
        console.log('âœ… Core initialization complete with critical fixes applied');
        console.log('ðŸ”§ Key improvements active:');
        console.log('  - 2-minute request timeout (eliminates 90s timeouts)');
        console.log('  - Proper timeout clearing prevents false timeouts');
        console.log('  - Retry logic with exponential backoff');
        console.log('  - Auto health monitoring and recovery');
        console.log('  - Enhanced error handling and logging');
        console.log('  - âœ… CRITICAL: Eliminated infinite recursion bug');
        
        // Show debug info after 3 seconds
        setTimeout(() => {
            debugEnhancements();
        }, 3000);
        
        console.log('ðŸŽ¯ Expected result: No more "Request queue timeout after 90s" errors');
        console.log('ðŸŽ¯ Expected result: No more "Maximum call stack size exceeded" errors');
    });
    
    console.log('âœ… Enhanced Main.js Loaded with Request Queue Fixes');
    console.log('ðŸš€ Ready for tab switching and server operations');

</script>
