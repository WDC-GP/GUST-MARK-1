<!-- ============================================================================
     GUST Bot Enhanced - Core JavaScript (REQUEST QUEUE TIMEOUT FIXES)
     ============================================================================
     ✅ FIXED: Request queue timeout increased from 30s to 90s
     ✅ FIXED: Queue processing logic improved
     ✅ FIXED: More lenient polling intervals
     ✅ FIXED: Better error handling and recovery
     ✅ PRESERVED: All core functionality
     ============================================================================ -->

<script>
    // ============================================================================
    // ENHANCED CONFIGURATION (FIXED TIMEOUTS)
    // ============================================================================
    
    const ENHANCED_CONFIG = {
        // ✅ FIXED: More reasonable polling intervals to prevent overload
        POLLING_INTERVALS: {
            servers: 10000,          // 10s (was 5s) - less aggressive
            player_count: 25000,     // 25s (was 15s) - more patient
            console: 15000,          // 15s (was 8s) - reduced frequency
            server_health: 90000     // 90s (was 45s) - background only
        },
        
        // ✅ FIXED: Much more lenient request throttling
        REQUEST_THROTTLING: {
            maxConcurrent: 2,        // Reduced from 3 - less aggressive
            minInterval: 750,        // Reduced from 1000ms - faster response
            queueTimeout: 90000      // ✅ CRITICAL: Increased from 30s to 90s
        },
        
        // ✅ FIXED: More patient authentication recovery
        AUTH_RECOVERY: {
            maxFailures: 5,          // Increased from 3 - more patient
            retryDelay: 3000,        // Increased from 2s - less aggressive  
            exponentialBackoff: true,
            redirectAfterFailures: 8  // Increased from 5 - more patient
        }
    };
    
    // ============================================================================
    // GLOBAL VARIABLES (PRESERVED)
    // ============================================================================
    
    let currentTab = 'dashboard';
    let managedServers = [];
    let selectedServers = new Set();
    let servers = [];
    let wsConnection = null;
    let isDemo = false;
    let connectionStatus = {};
    let serverFilter = '';
    let messageTypeFilter = 'all';
    let autoScroll = true;
    let websocketsAvailable = true;
    
    // ============================================================================
    // ✅ FIXED: REQUEST QUEUE CLASS WITH BETTER TIMEOUT HANDLING
    // ============================================================================
    
    class RequestQueue {
        constructor(maxConcurrent = 2, minInterval = 750) {
            this.maxConcurrent = maxConcurrent;
            this.minInterval = minInterval;
            this.activeRequests = 0;
            this.requestQueue = [];
            this.lastRequestTime = 0;
            this.isProcessing = false;
            this.failedRequests = 0;
            this.successfulRequests = 0;
            
            console.log(`✅ RequestQueue initialized: max ${maxConcurrent} concurrent, ${minInterval}ms min interval, ${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s timeout`);
        }
        
        async enqueue(requestFunction, priority = 'normal') {
            return new Promise((resolve, reject) => {
                const queueItem = {
                    requestFunction,
                    resolve,
                    reject,
                    priority,
                    timestamp: Date.now(),
                    timeout: null,  // Will be set after creation
                    id: Math.random().toString(36).substr(2, 9)  // Add ID for tracking
                };
                
                // ✅ FIXED: Set timeout with better error message
                queueItem.timeout = setTimeout(() => {
                    // Remove from queue if it's still there
                    const index = this.requestQueue.findIndex(item => item.id === queueItem.id);
                    if (index > -1) {
                        this.requestQueue.splice(index, 1);
                        console.warn(`⏰ Request queue timeout: ${queueItem.id} (${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s)`);
                    }
                    
                    this.failedRequests++;
                    reject(new Error(`Request queue timeout after ${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s - server may be busy`));
                }, ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout);
                
                // Insert based on priority
                if (priority === 'high') {
                    this.requestQueue.unshift(queueItem);
                } else {
                    this.requestQueue.push(queueItem);
                }
                
                // ✅ FIXED: Non-blocking queue processing
                setTimeout(() => this.processQueue(), 10);
            });
        }
        
        async processQueue() {
            // ✅ FIXED: Better queue processing logic
            if (this.isProcessing || this.requestQueue.length === 0) {
                return;
            }
            
            if (this.activeRequests >= this.maxConcurrent) {
                // ✅ FIXED: Retry processing after delay instead of giving up
                setTimeout(() => this.processQueue(), 500);
                return;
            }
            
            this.isProcessing = true;
            
            // Check minimum interval
            const now = Date.now();
            const timeSinceLastRequest = now - this.lastRequestTime;
            if (timeSinceLastRequest < this.minInterval) {
                setTimeout(() => {
                    this.isProcessing = false;
                    this.processQueue();
                }, this.minInterval - timeSinceLastRequest);
                return;
            }
            
            const queueItem = this.requestQueue.shift();
            if (!queueItem) {
                this.isProcessing = false;
                return;
            }
            
            // ✅ FIXED: Clear timeout to prevent false timeouts
            if (queueItem.timeout) {
                clearTimeout(queueItem.timeout);
                queueItem.timeout = null;
            }
            
            this.activeRequests++;
            this.lastRequestTime = now;
            
            try {
                console.log(`🔄 Processing queued request ${queueItem.id} (${this.activeRequests}/${this.maxConcurrent} active, ${this.requestQueue.length} queued)`);
                const result = await queueItem.requestFunction();
                queueItem.resolve(result);
                this.successfulRequests++;
            } catch (error) {
                console.error(`❌ Queued request ${queueItem.id} failed:`, error);
                queueItem.reject(error);
                this.failedRequests++;
            } finally {
                this.activeRequests--;
                this.isProcessing = false;
                
                // ✅ FIXED: Continue processing if queue has items
                if (this.requestQueue.length > 0) {
                    setTimeout(() => this.processQueue(), 100);
                }
            }
        }
        
        getStats() {
            return {
                activeRequests: this.activeRequests,
                queueLength: this.requestQueue.length,
                lastRequestTime: this.lastRequestTime,
                successfulRequests: this.successfulRequests,
                failedRequests: this.failedRequests,
                successRate: this.successfulRequests / Math.max(1, this.successfulRequests + this.failedRequests)
            };
        }
        
        // ✅ NEW: Queue health monitoring
        isHealthy() {
            const stats = this.getStats();
            return stats.queueLength < 10 && stats.successRate > 0.8;
        }
        
        // ✅ NEW: Clear queue in emergency
        clearQueue() {
            console.warn('🚨 Clearing request queue due to issues');
            this.requestQueue.forEach(item => {
                if (item.timeout) {
                    clearTimeout(item.timeout);
                }
                item.reject(new Error('Queue cleared due to issues'));
            });
            this.requestQueue = [];
        }
    }
    
    // ============================================================================
    // ✅ FIXED: AUTHENTICATION RECOVERY MANAGER WITH BETTER ERROR HANDLING
    // ============================================================================
    
    class AuthRecoveryManager {
        constructor() {
            this.failureCount = 0;
            this.consecutiveFailures = 0;
            this.lastFailureTime = 0;
            this.isRecovering = false;
            this.recoveryAttempts = 0;
            this.maxRecoveryAttempts = 3;
            
            console.log('✅ AuthRecoveryManager initialized with enhanced error handling');
        }
        
        recordFailure(response) {
            this.failureCount++;
            this.consecutiveFailures++;
            this.lastFailureTime = Date.now();
            
            console.warn(`⚠️ Auth failure recorded (${this.consecutiveFailures} consecutive, ${this.failureCount} total)`);
            
            // ✅ FIXED: More patient recovery strategy
            if (this.consecutiveFailures >= ENHANCED_CONFIG.AUTH_RECOVERY.maxFailures && !this.isRecovering) {
                if (this.recoveryAttempts < this.maxRecoveryAttempts) {
                    setTimeout(() => this.attemptRecovery(), ENHANCED_CONFIG.AUTH_RECOVERY.retryDelay);
                }
            }
            
            // ✅ FIXED: More patient before redirecting
            if (this.consecutiveFailures >= ENHANCED_CONFIG.AUTH_RECOVERY.redirectAfterFailures) {
                this.redirectToLogin();
            }
        }
        
        recordSuccess() {
            if (this.consecutiveFailures > 0) {
                console.log(`✅ Auth recovery successful after ${this.consecutiveFailures} failures`);
            }
            
            this.consecutiveFailures = 0;
            this.isRecovering = false;
            this.recoveryAttempts = 0;
        }
        
        async attemptRecovery() {
            if (this.isRecovering || this.recoveryAttempts >= this.maxRecoveryAttempts) {
                return false;
            }
            
            this.isRecovering = true;
            this.recoveryAttempts++;
            
            console.log(`🔄 Attempting auth recovery (attempt ${this.recoveryAttempts}/${this.maxRecoveryAttempts})`);
            
            try {
                // ✅ FIXED: Use request queue with high priority for recovery
                const tokenResponse = await requestQueue.enqueue(async () => {
                    return fetch('/api/token/status');
                }, 'high');
                
                const tokenData = await tokenResponse.json();
                
                if (!tokenData.token_valid && !tokenData.demo_mode) {
                    console.log('🔄 Token invalid, attempting refresh...');
                    
                    // Attempt token refresh with high priority
                    const refreshResponse = await requestQueue.enqueue(async () => {
                        return fetch('/api/token/refresh', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });
                    }, 'high');
                    
                    const refreshData = await refreshResponse.json();
                    
                    if (refreshData.success) {
                        console.log('✅ Token refresh successful during recovery');
                        this.recordSuccess();
                        return true;
                    } else {
                        console.error('❌ Token refresh failed during recovery');
                    }
                }
                
                // If we get here, recovery failed
                this.isRecovering = false;
                return false;
                
            } catch (error) {
                console.error('❌ Auth recovery error:', error);
                this.isRecovering = false;
                return false;
            }
        }
        
        redirectToLogin() {
            console.error('❌ Too many auth failures, redirecting to login');
            
            // Show user notification
            if (typeof showStatus === 'function') {
                showStatus('Session expired. Redirecting to login...', 'error');
            }
            
            // Redirect after short delay
            setTimeout(() => {
                window.location.href = '/login';
            }, 3000);  // ✅ FIXED: Longer delay for user to see message
        }
        
        shouldAttemptRecovery() {
            return this.consecutiveFailures >= ENHANCED_CONFIG.AUTH_RECOVERY.maxFailures && 
                   !this.isRecovering && 
                   this.recoveryAttempts < this.maxRecoveryAttempts;
        }
        
        getStats() {
            return {
                failureCount: this.failureCount,
                consecutiveFailures: this.consecutiveFailures,
                isRecovering: this.isRecovering,
                recoveryAttempts: this.recoveryAttempts,
                maxRecoveryAttempts: this.maxRecoveryAttempts,
                lastFailureTime: this.lastFailureTime
            };
        }
    }
    
    // ============================================================================
    // GLOBAL INSTANCES
    // ============================================================================
    
    const requestQueue = new RequestQueue(
        ENHANCED_CONFIG.REQUEST_THROTTLING.maxConcurrent,
        ENHANCED_CONFIG.REQUEST_THROTTLING.minInterval
    );
    
    const authRecovery = new AuthRecoveryManager();
    
    // ============================================================================
    // ✅ ENHANCED FETCH WRAPPER WITH BETTER ERROR HANDLING
    // ============================================================================
    
    const originalFetch = window.fetch;
    
    window.fetch = async function(url, options = {}) {
        return await requestQueue.enqueue(async () => {
            try {
                console.log(`🌐 Enhanced fetch: ${url}`);
                
                const response = await originalFetch(url, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                
                // ✅ FIXED: Better authentication error handling
                if (response.status === 401) {
                    console.warn('⚠️ Authentication error detected in fetch');
                    authRecovery.recordFailure(response);
                    
                    // Attempt recovery if appropriate
                    if (authRecovery.shouldAttemptRecovery()) {
                        const recoverySuccessful = await authRecovery.attemptRecovery();
                        
                        if (recoverySuccessful) {
                            // Retry the original request once
                            console.log('🔄 Retrying request after successful auth recovery');
                            return await originalFetch(url, options);
                        }
                    }
                } else if (response.ok) {
                    authRecovery.recordSuccess();
                }
                
                return response;
                
            } catch (error) {
                console.error('❌ Enhanced fetch error:', error);
                throw error;
            }
        }, options.priority || 'normal');
    };
    
    // ============================================================================
    // ✅ MISSING FUNCTION: addLiveConsoleMessage (IMMEDIATE AVAILABILITY)
    // ============================================================================
    
    function addLiveConsoleMessage(message, serverId = null, messageType = 'live') {
        const outputDiv = document.getElementById('consoleOutput');
        if (!outputDiv) {
            console.warn('⚠️ Console output div not found, using fallback');
            console.log(`[${messageType.toUpperCase()}] ${serverId ? `[${serverId}] ` : ''}${message}`);
            return;
        }
        
        // Handle different message formats
        let messageText, timestamp;
        if (typeof message === 'string') {
            messageText = message;
            timestamp = new Date();
        } else if (typeof message === 'object' && message !== null) {
            messageText = message.message || message.text || String(message);
            timestamp = message.timestamp ? new Date(message.timestamp) : new Date();
            messageType = message.type || messageType;
            serverId = message.serverId || message.server_id || serverId;
        } else {
            messageText = String(message);
            timestamp = new Date();
        }
        
        // Create message element
        const messageDiv = document.createElement('div');
        messageDiv.className = 'console-message text-sm mb-1 px-2 py-1 rounded';
        
        // Style based on message type
        const styles = {
            'live': 'text-green-400 bg-green-900 bg-opacity-20 border-l-2 border-green-400',
            'info': 'text-blue-400 bg-blue-900 bg-opacity-20 border-l-2 border-blue-400',
            'success': 'text-green-300 bg-green-900 bg-opacity-10',
            'error': 'text-red-400 bg-red-900 bg-opacity-20 border-l-2 border-red-400',
            'warning': 'text-yellow-400 bg-yellow-900 bg-opacity-20 border-l-2 border-yellow-400',
            'system': 'text-gray-300 bg-gray-900 bg-opacity-20 border-l-2 border-gray-400',
            'command': 'text-purple-400 bg-purple-900 bg-opacity-20 border-l-2 border-purple-400'
        };
        
        messageDiv.className += ' ' + (styles[messageType] || styles['live']);
        
        // Format message content
        const timeStr = timestamp.toLocaleTimeString();
        const serverPrefix = serverId ? `[${serverId}] ` : '';
        const typeIcon = getMessageTypeIcon(messageType);
        
        messageDiv.innerHTML = `
            <span class="text-gray-500 text-xs">[${timeStr}]</span>
            <span class="text-gray-400">${typeIcon}</span>
            ${serverPrefix}${escapeHtml(messageText)}
        `;
        
        // Add to output
        outputDiv.appendChild(messageDiv);
        
        // Auto-scroll to bottom if user isn't scrolled up
        try {
            const isNearBottom = outputDiv.scrollTop + outputDiv.clientHeight >= outputDiv.scrollHeight - 50;
            if (isNearBottom || outputDiv.children.length === 1) {
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        } catch (e) {
            // Fallback scroll
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }
        
        // Manage message limit (keep last 150 messages)
        const messages = outputDiv.children;
        if (messages.length > 150) {
            outputDiv.removeChild(messages[0]);
        }
    }
    
    function getMessageTypeIcon(type) {
        const icons = {
            'live': '📡',
            'info': 'ℹ️',
            'success': '✅',
            'error': '❌',
            'warning': '⚠️',
            'system': '🖥️',
            'command': '🔧',
            'chat': '💬',
            'auth': '🔐',
            'save': '💾',
            'kill': '⚔️',
            'player': '👥',
            'event': '🎯',
            'ban': '🚫',
            'health': '🏥'
        };
        return icons[type] || '📋';
    }
    
    function escapeHtml(text) {
        if (!text) return '';
        if (typeof text !== 'string') return String(text);
        
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // ============================================================================
    // CORE FUNCTIONS (ENHANCED WITH OPTIMIZATIONS)
    // ============================================================================
    
    function showTab(tab) {
        console.log('🔄 Switching to tab:', tab);
        
        try {
            currentTab = tab;
            
            document.querySelectorAll('.nav-tab').forEach(t => {
                if (t && t.classList) {
                    t.classList.remove('active');
                }
            });
            
            const navTab = document.getElementById(tab + '-tab');
            if (navTab && navTab.classList) {
                navTab.classList.add('active');
            }
            
            document.querySelectorAll('.view').forEach(view => {
                if (view && view.classList) {
                    view.classList.add('hidden');
                }
            });
            
            let targetView = document.getElementById(tab + '-view');
            if (!targetView) {
                targetView = document.getElementById(tab);
            }
            
            if (targetView && targetView.classList) {
                targetView.classList.remove('hidden');
                console.log('✅ Showing view:', targetView.id);
            } else {
                console.error('❌ No view found for tab:', tab);
                createPlaceholderView(tab);
                return;
            }
            
            // Load tab-specific data with proper modular calls
            try {
                if (tab === 'dashboard') loadDashboard();
                else if (tab === 'server-manager') loadServerManager();
                else if (tab === 'events') loadEvents();
                else if (tab === 'clans') loadClans();
                else if (tab === 'console') initializeConsole();
                else if (tab === 'user-management') loadUserManagement();
                else if (tab === 'users') loadUserManagement();
                else if (tab === 'logs') loadLogs();
                else if (tab === 'server-health') {
                    safeCall('loadServerHealth');
                }
            } catch (error) {
                console.warn('Tab-specific loader error:', error);
            }
            
            console.log('✅ Tab switch complete:', tab);
            
        } catch (error) {
            console.error('❌ showTab error:', error);
        }
    }
    
    function createPlaceholderView(tabId) {
        console.log('🔧 Creating placeholder view for:', tabId);
        
        let container = document.querySelector('.main-content') || document.querySelector('main') || document.body;
        
        const placeholderView = document.createElement('div');
        placeholderView.id = tabId + '-view';
        placeholderView.className = 'view bg-gray-800 p-6 rounded-lg';
        
        let title = tabId.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
        let content = '';
        
        switch(tabId) {
            case 'user-management':
            case 'users':
                title = '👤 User Management';
                content = `
                    <p class="text-gray-400 mb-4">User management functionality available...</p>
                    <div class="space-y-4">
                        <div class="bg-gray-700 p-4 rounded">
                            <h4 class="font-semibold mb-2">🚫 Temporary Ban User</h4>
                            <p class="text-sm text-gray-400">Ban management tools will be available here</p>
                        </div>
                        <div class="bg-gray-700 p-4 rounded">
                            <h4 class="font-semibold mb-2">🎁 Give Items</h4>
                            <p class="text-sm text-gray-400">Item distribution tools will be available here</p>
                        </div>
                    </div>
                `;
                break;
            case 'logs':
                title = '📋 Server Logs';
                content = `
                    <p class="text-gray-400 mb-4">Server logs functionality available...</p>
                    <div class="bg-gray-700 p-4 rounded">
                        <h4 class="font-semibold mb-2">📥 Log Management</h4>
                        <p class="text-sm text-gray-400">Download and view server logs available</p>
                    </div>
                `;
                break;
            default:
                content = `<p class="text-gray-400">This ${title} tab is under development...</p>`;
        }
        
        placeholderView.innerHTML = `
            <h2 class="text-2xl font-bold mb-4">${title}</h2>
            ${content}
            <div class="mt-6 p-4 bg-blue-900 bg-opacity-30 border border-blue-600 rounded">
                <p class="text-blue-300 text-sm">
                    <strong>🔧 Enhanced Note:</strong> This view now includes improved request queue with ${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s timeout
                    and better error recovery.
                </p>
            </div>
            <div class="mt-4 p-4 bg-green-900 bg-opacity-30 border border-green-600 rounded">
                <p class="text-green-300 text-sm">
                    <strong>⚡ ENHANCED:</strong> Optimized polling intervals - 
                    Servers: ${ENHANCED_CONFIG.POLLING_INTERVALS.servers/1000}s, 
                    Console: ${ENHANCED_CONFIG.POLLING_INTERVALS.console/1000}s, 
                    Player Count: ${ENHANCED_CONFIG.POLLING_INTERVALS.player_count/1000}s
                </p>
            </div>
        `;
        
        document.querySelectorAll('.view').forEach(view => {
            if (view && view.classList) {
                view.classList.add('hidden');
            }
        });
        
        container.appendChild(placeholderView);
        
        console.log('✅ Created enhanced placeholder view:', tabId + '-view');
    }

    function initializeConsole() {
        if (typeof refreshConsoleWithLiveMessages === 'function') {
            refreshConsoleWithLiveMessages();
        }
        if (typeof updateLiveConnectionStatus === 'function') {
            updateLiveConnectionStatus();
        }
        if (typeof updateConsoleFilters === 'function') {
            updateConsoleFilters();
        }
    }
    
    // ============================================================================
    // ✅ ENHANCED: SERVER MANAGEMENT WITH BETTER ERROR HANDLING
    // ============================================================================
    
    function updateAllServerDropdowns() {
        console.log('🔄 Updating all server dropdowns (enhanced)...');
        
        const serverDropdowns = [
            'consoleServerSelect',
            'eventServerSelect', 
            'clanServerSelect',
            'banServerSelect',
            'giveItemServerSelect',
            'liveTargetServer',
            'serverFilter',
            'server-health-selector',
            'server-select'
        ];
        
        let updatedDropdowns = 0;
        
        serverDropdowns.forEach(dropdownId => {
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) {
                return;
            }
            
            const currentValue = dropdown.value;
            const firstOption = dropdown.querySelector('option:first-child');
            dropdown.innerHTML = '';
            if (firstOption) {
                dropdown.appendChild(firstOption);
            }
            
            let addedOptions = 0;
            managedServers.filter(server => server.isActive).forEach(server => {
                const option = document.createElement('option');
                option.value = server.serverId;
                option.textContent = `${server.serverName} (${server.serverId}) - ${server.serverRegion}`;
                
                if (server.status === 'online') {
                    option.textContent += ' ✅';
                } else if (server.status === 'offline') {
                    option.textContent += ' ❌';
                }
                
                dropdown.appendChild(option);
                addedOptions++;
            });
            
            if (currentValue) {
                dropdown.value = currentValue;
            }
            
            updatedDropdowns++;
        });
        
        console.log(`✅ Enhanced server dropdowns updated: ${updatedDropdowns} dropdowns`);
        
        // Broadcast event
        const event = new CustomEvent('serverDropdownsUpdated', {
            detail: {
                serversCount: managedServers.length,
                updatedDropdowns: updatedDropdowns,
                enhanced: true
            }
        });
        window.dispatchEvent(event);
    }

    function getServerById(serverId) {
        return managedServers.find(server => server.serverId === serverId);
    }

    function refreshServerList() {
        console.log('🔄 Refreshing server list (enhanced)...');
        
        const container = document.getElementById('managedServersList');
        if (!container) {
            console.warn('⚠️ managedServersList container not found');
            return;
        }
        
        if (managedServers.length === 0) {
            container.innerHTML = `
                <div class="text-gray-400 text-center py-8">
                    <div class="text-4xl mb-4">🔍</div>
                    <div>No servers found</div>
                    <div class="text-sm mt-2">Add a new server above to get started</div>
                    <div class="text-xs mt-4 text-green-400">⚡ Enhanced with ${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s timeout</div>
                </div>
            `;
            return;
        }
        
        console.log(`📊 Rendering ${managedServers.length} servers (enhanced)`);
        
        container.innerHTML = managedServers.map(server => `
            <div class="bg-gray-700 p-4 rounded-lg border border-gray-600" data-server-id="${server.serverId}">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-4">
                        <div>
                            <div class="flex items-center space-x-2">
                                <h4 class="font-semibold text-lg">${server.serverName}</h4>
                                ${server.isFavorite ? '<span class="text-yellow-400">⭐</span>' : ''}
                                ${!server.isActive ? '<span class="text-red-400 text-xs bg-red-900 px-2 py-1 rounded">INACTIVE</span>' : ''}
                                <span class="text-xs bg-green-900 text-green-300 px-2 py-1 rounded">⚡ FIXED</span>
                            </div>
                            <div class="text-sm text-gray-300">
                                ID: ${server.serverId} | Region: ${server.serverRegion} | Type: ${server.serverType || 'Standard'}
                            </div>
                            ${server.description ? `<div class="text-xs text-gray-400 mt-1">${server.description}</div>` : ''}
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                        <div class="flex items-center space-x-2">
                            <span class="text-xs px-2 py-1 rounded ${getStatusClass(server.status)}">
                                ${getStatusText(server.status)}
                            </span>
                            ${server.lastPing ? `<span class="text-xs text-gray-400">Pinged: ${new Date(server.lastPing).toLocaleTimeString()}</span>` : ''}
                        </div>
                        
                        <button onclick="safeCall('pingSingleServer', '${server.serverId}')" 
                                class="bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded text-xs" title="Ping Server">
                            📡
                        </button>
                        <button onclick="safeCall('connectToLiveConsole', '${server.serverId}')" 
                                class="bg-green-600 hover:bg-green-700 px-2 py-1 rounded text-xs" title="Connect Live Console">
                            📺
                        </button>
                        <button onclick="safeCall('deleteServer', '${server.serverId}')" 
                                class="bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-xs" title="Delete Server">
                            🗑️
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
        
        console.log('✅ Enhanced server list refreshed');
    }
    
    // ============================================================================
    // ✅ FIXED: PING SERVER WITH BETTER ERROR HANDLING
    // ============================================================================
    
    async function pingSingleServer(serverId) {
        console.log(`📡 Pinging server: ${serverId}`);
        
        try {
            // ✅ FIXED: Use enhanced fetch with high priority and longer timeout
            const response = await fetch(`/api/servers/ping/${serverId}`, {
                method: 'POST',
                priority: 'high',  // High priority for ping requests
                signal: AbortSignal.timeout(60000)  // 60 second timeout for ping
            });
            
            const result = await response.json();
            
            if (result.success || result.status) {  // Success or valid status response
                // Update server status in local list
                const server = managedServers.find(s => s.serverId === serverId);
                if (server) {
                    server.status = result.status;
                    server.lastPing = result.ping_time || new Date().toISOString();
                    server.responseTime = result.response_time_ms;
                    server.lastPingStatus = result.message;
                }
                
                // Refresh displays
                refreshServerList();
                updateAllServerDropdowns();
                
                // Show success message with details
                const statusEmoji = result.status === 'online' ? '✅' : 
                                  result.status === 'timeout' ? '⏰' : 
                                  result.status === 'offline' ? '🔴' : '⚠️';
                
                const message = `${statusEmoji} Ping ${result.server_name || serverId}: ${result.message} (${result.response_time_ms}ms)`;
                showStatus(message, result.success ? 'success' : 'warning');
                
                // Add to console if available
                if (typeof addLiveConsoleMessage === 'function') {
                    addLiveConsoleMessage(message, serverId, result.success ? 'success' : 'warning');
                }
                
                console.log(`✅ Ping result for ${serverId}:`, result);
                
            } else {
                // Handle ping failure
                const errorMsg = `❌ Ping failed for ${serverId}: ${result.error || 'Unknown error'}`;
                showStatus(errorMsg, 'error');
                
                if (typeof addLiveConsoleMessage === 'function') {
                    addLiveConsoleMessage(errorMsg, serverId, 'error');
                }
                
                console.error('Ping failed:', result);
            }
            
        } catch (error) {
            const errorMsg = `❌ Ping error for ${serverId}: ${error.message}`;
            showStatus(errorMsg, 'error');
            
            if (typeof addLiveConsoleMessage === 'function') {
                addLiveConsoleMessage(errorMsg, serverId, 'error');
            }
            
            console.error('Ping error:', error);
        }
    }
    
    async function pingAllServers() {
        console.log('📡 Pinging all active servers...');
        
        const activeServers = managedServers.filter(server => server.isActive);
        if (activeServers.length === 0) {
            showStatus('⚠️ No active servers to ping', 'warning');
            return;
        }
        
        showStatus(`📡 Pinging ${activeServers.length} servers...`, 'info');
        
        // ✅ FIXED: Use sequential pings to avoid overwhelming the queue
        let successful = 0;
        let failed = 0;
        
        for (const server of activeServers) {
            try {
                await pingSingleServer(server.serverId);
                successful++;
            } catch (error) {
                failed++;
                console.error(`Ping failed for ${server.serverId}:`, error);
            }
            
            // Small delay between pings
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        const summaryMsg = `📊 Ping complete: ${successful} successful, ${failed} failed`;
        showStatus(summaryMsg, failed === 0 ? 'success' : 'warning');
        
        if (typeof addLiveConsoleMessage === 'function') {
            addLiveConsoleMessage(summaryMsg, null, 'info');
        }
    }
    
    // ============================================================================
    // ✅ ENHANCED: MODULAR FUNCTION LOADING WITH BETTER ERROR HANDLING
    // ============================================================================
    
    function loadDashboard() {
        console.log('📊 Loading Dashboard...');
        
        try {
            // Enhanced dashboard loading with request queue
            requestQueue.enqueue(async () => {
                const response = await fetch('/api/events');
                return response.json();
            }, 'normal').then(events => {
                console.log('✅ Dashboard events loaded');
                // Process events data here
            }).catch(error => {
                console.warn('⚠️ Dashboard events load failed:', error);
            });
            
            // Update system status
            if (typeof updateSystemStatus === 'function') {
                updateSystemStatus();
            }
            
        } catch (error) {
            console.error('❌ Dashboard load error:', error);
        }
    }
    
    function loadServerManager() {
        console.log('🖥️ Loading Server Manager...');
        
        try {
            // Load managed servers with enhanced error handling
            if (typeof loadManagedServers === 'function') {
                loadManagedServers().then(() => {
                    console.log('✅ Server Manager loaded');
                }).catch(error => {
                    console.warn('⚠️ Server Manager load failed:', error);
                });
            } else {
                // Fallback server loading
                requestQueue.enqueue(async () => {
                    const response = await fetch('/api/servers');
                    const servers = await response.json();
                    managedServers.length = 0;
                    managedServers.push(...servers);
                    updateAllServerDropdowns();
                    refreshServerList();
                    return servers;
                }, 'high').catch(error => {
                    console.error('❌ Fallback server loading failed:', error);
                });
            }
            
        } catch (error) {
            console.error('❌ Server Manager load error:', error);
        }
    }
    
    function loadEvents() {
        console.log('🎯 Loading Events...');
        
        try {
            if (typeof loadEventList === 'function') {
                loadEventList();
            } else {
                // Fallback event loading
                requestQueue.enqueue(async () => {
                    const response = await fetch('/api/events');
                    return response.json();
                }, 'normal').then(events => {
                    console.log('✅ Events loaded (fallback)');
                }).catch(error => {
                    console.warn('⚠️ Events load failed:', error);
                });
            }
        } catch (error) {
            console.error('❌ Events load error:', error);
        }
    }
    
    function loadClans() {
        console.log('👥 Loading Clans...');
        
        try {
            if (typeof refreshClanList === 'function') {
                refreshClanList();
            } else {
                // Fallback clan loading
                requestQueue.enqueue(async () => {
                    const response = await fetch('/api/clans');
                    return response.json();
                }, 'normal').then(clans => {
                    console.log('✅ Clans loaded (fallback)');
                }).catch(error => {
                    console.warn('⚠️ Clans load failed:', error);
                });
            }
        } catch (error) {
            console.error('❌ Clans load error:', error);
        }
    }
    
    function loadUserManagement() {
        console.log('👤 Loading User Management...');
        
        try {
            if (typeof refreshUserList === 'function') {
                refreshUserList();
            } else {
                // Fallback user loading
                requestQueue.enqueue(async () => {
                    const response = await fetch('/api/users');
                    return response.json();
                }, 'normal').then(users => {
                    console.log('✅ Users loaded (fallback)');
                }).catch(error => {
                    console.warn('⚠️ Users load failed:', error);
                });
            }
        } catch (error) {
            console.error('❌ User Management load error:', error);
        }
    }
    
    function loadLogs() {
        console.log('📋 Loading Logs...');
        
        try {
            if (typeof initializeLogs === 'function') {
                initializeLogs();
            } else if (typeof loadLogsList === 'function') {
                loadLogsList();
            } else {
                // Fallback logs loading
                requestQueue.enqueue(async () => {
                    const response = await fetch('/api/logs');
                    return response.json();
                }, 'normal').then(logs => {
                    console.log('✅ Logs loaded (fallback)');
                }).catch(error => {
                    console.warn('⚠️ Logs load failed:', error);
                });
            }
        } catch (error) {
            console.error('❌ Logs load error:', error);
        }
    }
    
    // ============================================================================
    // ✅ ENHANCED: CONNECTION AND AUTO-CONNECT FUNCTIONS
    // ============================================================================
    
    function connectToLiveConsole(serverId, serverName) {
        console.log(`🔌 Connecting to live console: ${serverName || serverId}`);
        
        try {
            // Switch to console tab
            if (typeof showTab === 'function') {
                showTab('console');
            }
            
            // Update console server selection
            const consoleSelect = document.getElementById('consoleServerSelect');
            if (consoleSelect) {
                consoleSelect.value = serverId;
            }
            
            // Add connection message
            if (typeof addLiveConsoleMessage === 'function') {
                addLiveConsoleMessage(
                    `🔌 Connected to live console for ${serverName || serverId}`, 
                    serverId, 
                    'success'
                );
            }
            
            // Trigger auto-connection if available
            if (typeof autoConnectToServer === 'function') {
                autoConnectToServer(serverId, serverName);
            }
            
            console.log(`✅ Live console connection established for ${serverId}`);
            
        } catch (error) {
            console.error('❌ Live console connection error:', error);
            
            if (typeof addLiveConsoleMessage === 'function') {
                addLiveConsoleMessage(
                    `❌ Failed to connect to ${serverName || serverId}: ${error.message}`, 
                    serverId, 
                    'error'
                );
            }
        }
    }
    
    function deleteServer(serverId) {
        console.log(`🗑️ Deleting server: ${serverId}`);
        
        const server = getServerById(serverId);
        if (!server) {
            showStatus('⚠️ Server not found', 'warning');
            return;
        }
        
        const serverName = server.serverName || serverId;
        
        if (!confirm(`Are you sure you want to delete "${serverName}"?\n\nThis action cannot be undone.`)) {
            return;
        }
        
        // Use enhanced fetch with request queue
        requestQueue.enqueue(async () => {
            const response = await fetch(`/api/servers/delete/${serverId}`, {
                method: 'POST'
            });
            return response.json();
        }, 'high').then(result => {
            if (result.success) {
                // Remove from local array
                const index = managedServers.findIndex(s => s.serverId === serverId);
                if (index !== -1) {
                    managedServers.splice(index, 1);
                }
                
                // Update displays
                updateAllServerDropdowns();
                refreshServerList();
                
                const successMsg = `✅ Server "${serverName}" deleted successfully`;
                showStatus(successMsg, 'success');
                
                if (typeof addLiveConsoleMessage === 'function') {
                    addLiveConsoleMessage(successMsg, serverId, 'success');
                }
                
                console.log(`✅ Server deleted: ${serverName}`);
                
            } else {
                const errorMsg = `❌ Failed to delete server: ${result.error || 'Unknown error'}`;
                showStatus(errorMsg, 'error');
                console.error('Delete server failed:', result);
            }
        }).catch(error => {
            const errorMsg = `❌ Error deleting server: ${error.message}`;
            showStatus(errorMsg, 'error');
            console.error('Delete server error:', error);
        });
    }
    
    // ============================================================================
    // ✅ ENHANCED: MONITORING AND DEBUG FUNCTIONS
    // ============================================================================
    
    function getEnhancementStats() {
        return {
            config: ENHANCED_CONFIG,
            requestQueue: requestQueue.getStats(),
            authRecovery: authRecovery.getStats(),
            timestamp: new Date().toISOString(),
            queueHealthy: requestQueue.isHealthy()
        };
    }
    
    function debugEnhancements() {
        console.log('🔍 ENHANCEMENT DEBUG INFO (FIXED VERSION):');
        console.log('============================================');
        console.log('Polling intervals:');
        Object.entries(ENHANCED_CONFIG.POLLING_INTERVALS).forEach(([key, value]) => {
            console.log(`  - ${key}: ${value/1000}s`);
        });
        
        console.log(`Queue timeout: ${ENHANCED_CONFIG.REQUEST_THROTTLING.queueTimeout/1000}s (FIXED from 30s)`);
        
        const stats = getEnhancementStats();
        console.log('Request queue:', stats.requestQueue);
        console.log('Auth recovery:', stats.authRecovery);
        console.log('Queue healthy:', stats.queueHealthy);
        
        console.log('Expected improvements:');
        console.log('  - ✅ FIXED: 90s queue timeout (was 30s)');
        console.log('  - ✅ FIXED: Better queue processing logic');
        console.log('  - ✅ FIXED: More lenient auth recovery');
        console.log('  - ✅ FIXED: Sequential ping operations');
        
        if (!stats.queueHealthy) {
            console.warn('⚠️ Request queue unhealthy - consider clearing');
        }
    }
    
    // ============================================================================
    // UTILITY FUNCTIONS (PRESERVED)
    // ============================================================================
    
    function showStatus(message, type = 'info') {
        console.log(`Status [${type.toUpperCase()}]: ${message}`);
        
        // Try to update status display if available
        const statusDiv = document.getElementById('statusMessage');
        if (statusDiv) {
            statusDiv.className = `status-message ${type}`;
            statusDiv.textContent = message;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = 'status-message';
            }, 5000);
        }
    }
    
    function getStatusClass(status) {
        switch(status) {
            case 'online': return 'bg-green-800 text-green-200';
            case 'offline': return 'bg-red-800 text-red-200';
            case 'timeout': return 'bg-yellow-800 text-yellow-200';
            default: return 'bg-gray-700 text-gray-300';
        }
    }
    
    function getStatusText(status) {
        switch(status) {
            case 'online': return '🟢 Online';
            case 'offline': return '🔴 Offline';
            case 'timeout': return '⏰ Timeout';
            default: return '⚪ Unknown';
        }
    }
    
    function safeCall(functionName, ...args) {
        try {
            if (typeof window[functionName] === 'function') {
                return window[functionName](...args);
            } else {
                console.warn(`Function ${functionName} not available yet`);
                return null;
            }
        } catch (error) {
            console.error(`Error calling ${functionName}:`, error);
            return null;
        }
    }
    
    // ============================================================================
    // GLOBAL FUNCTION EXPOSURE (ENHANCED)
    // ============================================================================
    
    // Core functions
    window.showTab = showTab;
    window.createPlaceholderView = createPlaceholderView;
    window.getServerById = getServerById;
    window.updateAllServerDropdowns = updateAllServerDropdowns;
    window.refreshServerList = refreshServerList;
    window.initializeConsole = initializeConsole;
    window.getStatusClass = getStatusClass;
    window.getStatusText = getStatusText;
    window.safeCall = safeCall;
    window.showStatus = showStatus;
    
    // ✅ FIXED: Missing functions
    window.addLiveConsoleMessage = addLiveConsoleMessage;
    window.pingSingleServer = pingSingleServer;
    window.pingAllServers = pingAllServers;
    window.connectToLiveConsole = connectToLiveConsole;
    window.deleteServer = deleteServer;
    
    // Enhanced modular loading functions
    window.loadDashboard = loadDashboard;
    window.loadServerManager = loadServerManager;
    window.loadEvents = loadEvents;
    window.loadClans = loadClans;
    window.loadUserManagement = loadUserManagement;
    window.loadLogs = loadLogs;
    
    // ✅ FIXED: Enhanced functions
    window.requestQueue = requestQueue;
    window.authRecovery = authRecovery;
    window.getEnhancementStats = getEnhancementStats;
    window.debugEnhancements = debugEnhancements;
    window.ENHANCED_CONFIG = ENHANCED_CONFIG;
    window.escapeHtml = escapeHtml;
    window.getMessageTypeIcon = getMessageTypeIcon;
    
    // Global variables
    window.currentTab = currentTab;
    window.servers = servers;
    window.managedServers = managedServers;
    window.selectedServers = selectedServers;
    window.wsConnection = wsConnection;
    window.isDemo = isDemo;
    window.connectionStatus = connectionStatus;
    window.serverFilter = serverFilter;
    window.messageTypeFilter = messageTypeFilter;
    window.autoScroll = autoScroll;
    window.websocketsAvailable = websocketsAvailable;
    
    console.log('🚀 GUST Bot Enhanced - Core Module Loaded (REQUEST QUEUE FIXES)');
    console.log('⚡ MAJOR FIXES ACTIVE:');
    console.log('  - Request queue timeout: 90s (was 30s) - FIXED');
    console.log('  - Queue processing: Improved logic - FIXED');
    console.log('  - Polling intervals: More reasonable timing');
    console.log('  - Auth recovery: More patient strategy');
    console.log('🎯 Request queue timeout errors should be eliminated');
    console.log('🔧 Debug functions: debugEnhancements(), getEnhancementStats()');
    
    // ============================================================================
    // INITIALIZATION WITH ENHANCEMENTS
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log('📋 DOM loaded - setting up enhanced event handlers');
        
        // Set up hash change handling
        window.addEventListener('hashchange', function() {
            const tab = window.location.hash.substring(1);
            if (tab && typeof window.showTab === 'function') {
                window.showTab(tab);
            }
        });
        
        // Initialize with hash or default tab
        setTimeout(function() {
            if (window.location.hash) {
                const tab = window.location.hash.substring(1);
                if (tab && typeof window.showTab === 'function') {
                    window.showTab(tab);
                }
            } else {
                if (typeof window.showTab === 'function') {
                    window.showTab('dashboard');
                }
            }
        }, 500);
        
        // ✅ NEW: Enhanced monitoring with queue health checks
        setInterval(() => {
            const stats = requestQueue.getStats();
            if (stats.queueLength > 15) {
                console.warn('⚠️ Request queue getting long:', stats);
            }
            if (!requestQueue.isHealthy()) {
                console.warn('⚠️ Request queue unhealthy:', stats);
            }
        }, 30000); // Check every 30 seconds
        
        console.log('✅ Enhanced core initialization complete');
        console.log('🌐 Available functions:', {
            showTab: typeof window.showTab,
            currentTab: window.currentTab,
            enhancedFetch: typeof window.fetch,
            requestQueue: typeof window.requestQueue,
            authRecovery: typeof window.authRecovery,
            debugEnhancements: typeof window.debugEnhancements,
            addLiveConsoleMessage: typeof window.addLiveConsoleMessage,
            pingSingleServer: typeof window.pingSingleServer,
            connectToLiveConsole: typeof window.connectToLiveConsole,
            deleteServer: typeof window.deleteServer
        });
        
        // ✅ FIXED: Show enhancement status
        setTimeout(() => {
            debugEnhancements();
        }, 3000);
    });

</script>