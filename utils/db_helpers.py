"""
Database helper functions for GUST Bot Enhanced - CORRECTED VERSION
=================================================================
Consolidates repeated database operation patterns across the project
Generated by GUST-MARK-1 optimization script on 06/18/2025 17:56:44

‚úÖ FIXES APPLIED:
- Added missing get_db_connection function (CRITICAL FIX)
- Fixed MongoDB syntax errors ($set operators)
- Enhanced error handling and connection management
- Maintained all existing functionality from your current file

This module provides standardized database operations with proper
error handling, logging, and consistent patterns.
"""

# Standard library imports
import os
import time
from datetime import datetime
import logging

# Third-party imports
from bson import ObjectId
from pymongo.errors import PyMongoError, DuplicateKeyError, ConnectionFailure
from typing import Dict, List, Optional, Any

# GUST database optimization imports
from utils.gust_db_optimization import (
    get_user_with_cache,
    get_user_balance_cached,
    update_user_balance,
    db_performance_monitor
)

logger = logging.getLogger(__name__)

# ==========================================
# MISSING FUNCTION - get_db_connection (CRITICAL FIX)
# ==========================================

def get_db_connection(connection_string=None, database_name=None):
    """
    Get database connection with proper error handling and configuration
    
    Args:
        connection_string (str, optional): MongoDB connection string
        database_name (str, optional): Database name to connect to
        
    Returns:
        tuple: (database_object, connection_success_bool)
    """
    try:
        # Try to import MongoDB client
        from pymongo import MongoClient
        from pymongo.errors import ConnectionFailure, ServerSelectionTimeoutError
        
        # Default configuration
        if not connection_string:
            connection_string = os.getenv('MONGODB_URI', 'mongodb://localhost:27017/')
        
        if not database_name:
            database_name = os.getenv('DATABASE_NAME', 'gust_bot_db')
        
        # Create MongoDB client with timeout settings
        client = MongoClient(
            connection_string,
            serverSelectionTimeoutMS=5000,  # 5 second timeout
            connectTimeoutMS=10000,         # 10 second connection timeout
            socketTimeoutMS=20000,          # 20 second socket timeout
            maxPoolSize=50,                 # Connection pool size
            retryWrites=True
        )
        
        # Test the connection
        client.admin.command('ping')
        
        # Get database
        database = client[database_name]
        
        logger.info(f"‚úÖ Successfully connected to MongoDB database: {database_name}")
        return database, True
        
    except (ConnectionFailure, ServerSelectionTimeoutError) as e:
        logger.error(f"‚ùå MongoDB connection failed: {str(e)}")
        logger.info("üìã Falling back to in-memory storage...")
        return None, False
        
    except ImportError:
        logger.warning("‚ö†Ô∏è PyMongo not installed, using in-memory storage")
        return None, False
        
    except Exception as e:
        logger.error(f"‚ùå Unexpected database connection error: {str(e)}")
        return None, False

def get_db_connection_with_retry(max_retries=3, retry_delay=2):
    """
    Get database connection with retry logic
    
    Args:
        max_retries (int): Maximum number of connection attempts
        retry_delay (int): Delay between retries in seconds
        
    Returns:
        tuple: (database_object, connection_success_bool)
    """
    for attempt in range(max_retries):
        try:
            db, success = get_db_connection()
            if success:
                return db, True
            
            if attempt < max_retries - 1:
                logger.info(f"üîÑ Retrying database connection in {retry_delay} seconds... (Attempt {attempt + 1}/{max_retries})")
                time.sleep(retry_delay)
                
        except Exception as e:
            logger.error(f"‚ùå Connection attempt {attempt + 1} failed: {str(e)}")
            if attempt < max_retries - 1:
                time.sleep(retry_delay)
    
    logger.error(f"‚ùå All {max_retries} database connection attempts failed")
    return None, False

def test_db_connection(db):
    """
    Test database connection health
    
    Args:
        db: Database object to test
        
    Returns:
        bool: True if connection is healthy, False otherwise
    """
    try:
        if not db:
            return False
            
        # Test with a simple operation
        db.command('ping')
        logger.info("‚úÖ Database connection test successful")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Database connection test failed: {str(e)}")
        return False

# ==========================================
# YOUR EXISTING DATABASE HELPER CLASS (CORRECTED)
# ==========================================

class DatabaseHelper:
    """Centralized database operations with error handling and logging"""
    
    def __init__(self, db_connection=None):
        self.db = db_connection
        self.logger = logger
        self.connection_attempts = 0
        self.last_operation_time = None
    
    def is_connected(self):
        """Check if database is connected and responsive"""
        return test_db_connection(self.db)
    
    def reconnect_if_needed(self):
        """Attempt to reconnect if connection is lost"""
        if not self.is_connected():
            logger.warning("‚ö†Ô∏è Database connection lost, attempting to reconnect...")
            self.db, success = get_db_connection_with_retry()
            return success
        return True
    
    def safe_find_one(self, collection, query: Dict, default: Any = None) -> Optional[Dict]:
        """
        Safely find one document with comprehensive error handling
        
        Args:
            collection: MongoDB collection object or collection name
            query: MongoDB query dictionary
            default: Default value if document not found or error occurs
            
        Returns:
            Document dictionary or default value
        """
        try:
            # Handle both collection object and collection name
            if isinstance(collection, str):
                if not self.reconnect_if_needed():
                    return default
                collection = self.db[collection]
            
            start_time = time.time()
            result = collection.find_one(query)
            
            operation_time = time.time() - start_time
            self.last_operation_time = operation_time
            
            if result:
                self.logger.debug(f"Found document in {collection.name} with query: {query}")
                return result
            else:
                self.logger.debug(f"No document found in {collection.name} with query: {query}")
                return default
                
        except PyMongoError as e:
            self.logger.error(f"Database find_one error in {getattr(collection, 'name', 'unknown')}: {e}")
            return default
        except Exception as e:
            self.logger.error(f"Unexpected error in find_one: {e}")
            return default
    
    def safe_insert_one(self, collection, document: Dict) -> Optional[str]:
        """
        Safely insert document with error handling
        
        Args:
            collection: MongoDB collection object or collection name
            document: Document to insert
            
        Returns:
            Inserted document ID as string or None if failed
        """
        try:
            # Handle both collection object and collection name
            if isinstance(collection, str):
                if not self.reconnect_if_needed():
                    return None
                collection = self.db[collection]
            
            # Add timestamp if not present
            if 'created_at' not in document:
                document['created_at'] = datetime.utcnow()
            
            start_time = time.time()
            result = collection.insert_one(document)
            
            operation_time = time.time() - start_time
            self.last_operation_time = operation_time
            
            self.logger.info(f"Successfully inserted document in {collection.name}: {result.inserted_id}")
            return str(result.inserted_id)
            
        except DuplicateKeyError as e:
            self.logger.warning(f"Duplicate key error in {getattr(collection, 'name', 'unknown')}: {e}")
            return None
        except PyMongoError as e:
            self.logger.error(f"Database insert error in {getattr(collection, 'name', 'unknown')}: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Unexpected error in insert_one: {e}")
            return None
    
    def safe_update_one(self, collection, query: Dict, update: Dict, upsert: bool = False) -> bool:
        """
        Safely update one document with error handling
        
        Args:
            collection: MongoDB collection object or collection name
            query: MongoDB query to find document
            update: Update operations dictionary
            upsert: Whether to insert if document doesn't exist
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Handle both collection object and collection name
            if isinstance(collection, str):
                if not self.reconnect_if_needed():
                    return False
                collection = self.db[collection]
            
            # FIXED: Add timestamp to update with proper MongoDB syntax
            if '$set' in update:
                update['$set']['updated_at'] = datetime.utcnow()
            else:
                update['$set'] = {'updated_at': datetime.utcnow()}
            
            start_time = time.time()
            result = collection.update_one(query, update, upsert=upsert)
            
            operation_time = time.time() - start_time
            self.last_operation_time = operation_time
            
            if result.modified_count > 0 or (upsert and result.upserted_id):
                self.logger.info(f"Successfully updated document in {collection.name}")
                return True
            else:
                self.logger.warning(f"No document updated in {collection.name} with query: {query}")
                return False
                
        except PyMongoError as e:
            self.logger.error(f"Database update error in {getattr(collection, 'name', 'unknown')}: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in update_one: {e}")
            return False
    
    def safe_delete_one(self, collection, query: Dict) -> bool:
        """
        Safely delete one document with error handling
        
        Args:
            collection: MongoDB collection object or collection name
            query: MongoDB query to find document to delete
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Handle both collection object and collection name
            if isinstance(collection, str):
                if not self.reconnect_if_needed():
                    return False
                collection = self.db[collection]
            
            start_time = time.time()
            result = collection.delete_one(query)
            
            operation_time = time.time() - start_time
            self.last_operation_time = operation_time
            
            if result.deleted_count > 0:
                self.logger.info(f"Successfully deleted document from {collection.name}")
                return True
            else:
                self.logger.warning(f"No document deleted from {collection.name} with query: {query}")
                return False
                
        except PyMongoError as e:
            self.logger.error(f"Database delete error in {getattr(collection, 'name', 'unknown')}: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in delete_one: {e}")
            return False
    
    def safe_find_many(self, collection, query: Dict, sort: Optional[List] = None, limit: Optional[int] = None) -> List[Dict]:
        """
        Safely find multiple documents with error handling
        
        Args:
            collection: MongoDB collection object or collection name
            query: MongoDB query dictionary
            sort: Sort parameters
            limit: Maximum number of documents to return
            
        Returns:
            List of documents or empty list if error
        """
        try:
            # Handle both collection object and collection name
            if isinstance(collection, str):
                if not self.reconnect_if_needed():
                    return []
                collection = self.db[collection]
            
            start_time = time.time()
            cursor = collection.find(query)
            
            if sort:
                cursor = cursor.sort(sort)
            if limit:
                cursor = cursor.limit(limit)
            
            results = list(cursor)
            
            operation_time = time.time() - start_time
            self.last_operation_time = operation_time
            
            self.logger.debug(f"Found {len(results)} documents in {collection.name}")
            return results
            
        except PyMongoError as e:
            self.logger.error(f"Database find_many error in {getattr(collection, 'name', 'unknown')}: {e}")
            return []
        except Exception as e:
            self.logger.error(f"Unexpected error in find_many: {e}")
            return []
    
    def safe_update_many(self, collection, query: Dict, update: Dict) -> int:
        """
        Safely update multiple documents with error handling
        
        Args:
            collection: MongoDB collection object or collection name
            query: MongoDB query to find documents
            update: Update operations dictionary
            
        Returns:
            Number of documents modified
        """
        try:
            # Handle both collection object and collection name
            if isinstance(collection, str):
                if not self.reconnect_if_needed():
                    return 0
                collection = self.db[collection]
            
            # Add timestamp to update with proper MongoDB syntax
            if '$set' in update:
                update['$set']['updated_at'] = datetime.utcnow()
            else:
                update['$set'] = {'updated_at': datetime.utcnow()}
            
            start_time = time.time()
            result = collection.update_many(query, update)
            
            operation_time = time.time() - start_time
            self.last_operation_time = operation_time
            
            modified_count = result.modified_count if result.acknowledged else 0
            self.logger.info(f"Updated {modified_count} documents in {collection.name}")
            
            return modified_count
            
        except PyMongoError as e:
            self.logger.error(f"Database update_many error in {getattr(collection, 'name', 'unknown')}: {e}")
            return 0
        except Exception as e:
            self.logger.error(f"Unexpected error in update_many: {e}")
            return 0
    
    def safe_count_documents(self, collection, query: Dict = None) -> int:
        """
        Safely count documents with error handling
        
        Args:
            collection: MongoDB collection object or collection name
            query: Query to filter documents (optional)
            
        Returns:
            Number of documents matching query
        """
        try:
            # Handle both collection object and collection name
            if isinstance(collection, str):
                if not self.reconnect_if_needed():
                    return 0
                collection = self.db[collection]
            
            if query is None:
                query = {}
            
            start_time = time.time()
            count = collection.count_documents(query)
            
            operation_time = time.time() - start_time
            self.last_operation_time = operation_time
            
            return count
            
        except PyMongoError as e:
            self.logger.error(f"Database count_documents error in {getattr(collection, 'name', 'unknown')}: {e}")
            return 0
        except Exception as e:
            self.logger.error(f"Unexpected error in count_documents: {e}")
            return 0
    
    def validate_object_id(self, id_string: str) -> Optional[ObjectId]:
        """
        Validate and convert string to ObjectId
        
        Args:
            id_string: String representation of ObjectId
            
        Returns:
            ObjectId if valid, None otherwise
        """
        try:
            return ObjectId(id_string)
        except Exception:
            self.logger.warning(f"Invalid ObjectId format: {id_string}")
            return None
    
    def test_connection(self) -> bool:
        """
        Test database connection
        
        Returns:
            True if connection is healthy, False otherwise
        """
        try:
            if self.db:
                self.db.admin.command('ping')
                self.logger.info("Database connection test successful")
                return True
            else:
                self.logger.error("No database connection available")
                return False
        except ConnectionFailure as e:
            self.logger.error(f"Database connection failed: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in connection test: {e}")
            return False

# ==========================================
# YOUR EXISTING UTILITY FUNCTIONS (MAINTAINED)
# ==========================================

def get_server_collection(db, server_id: str):
    """Get server-specific collection name"""
    return db[f"server_{server_id}"]

def ensure_indexes(collection, indexes: List[Dict]):
    """Ensure indexes exist on collection"""
    try:
        for index in indexes:
            collection.create_index(index.get('keys'), **index.get('options', {}))
        logger.info(f"Indexes ensured for collection {collection.name}")
    except Exception as e:
        logger.error(f"Error ensuring indexes: {e}")

# ==========================================
# CONVENIENCE FUNCTIONS
# ==========================================

def create_database_helper(connection_string=None, database_name=None) -> Optional[DatabaseHelper]:
    """
    Create a DatabaseHelper instance with automatic connection
    
    Args:
        connection_string: MongoDB connection string (optional)
        database_name: Database name (optional)
        
    Returns:
        DatabaseHelper instance or None if connection failed
    """
    db, success = get_db_connection(connection_string, database_name)
    if success:
        return DatabaseHelper(db)
    return None

def get_database_health_status(db_helper: DatabaseHelper) -> Dict[str, Any]:
    """
    Get comprehensive database health status
    
    Args:
        db_helper: DatabaseHelper instance
        
    Returns:
        Dictionary with health status information
    """
    try:
        if not db_helper or not db_helper.is_connected():
            return {
                'status': 'disconnected',
                'healthy': False,
                'last_operation_time': getattr(db_helper, 'last_operation_time', None) if db_helper else None,
                'connection_attempts': getattr(db_helper, 'connection_attempts', 0) if db_helper else 0
            }
        
        # Test basic operations
        test_start = time.time()
        server_info = db_helper.db.command('serverStatus')
        test_time = time.time() - test_start
        
        return {
            'status': 'connected',
            'healthy': True,
            'server_version': server_info.get('version', 'unknown'),
            'uptime_seconds': server_info.get('uptime', 0),
            'last_operation_time': db_helper.last_operation_time,
            'test_query_time': test_time,
            'connection_attempts': db_helper.connection_attempts
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error getting database health status: {str(e)}")
        return {
            'status': 'error',
            'healthy': False,
            'error': str(e),
            'last_operation_time': getattr(db_helper, 'last_operation_time', None) if db_helper else None
        }

# ==========================================
# LEGACY COMPATIBILITY FUNCTIONS (FROM YOUR ORIGINAL)
# ==========================================

def safe_find_one(collection, query, projection=None):
    """Legacy wrapper for backwards compatibility"""
    try:
        if projection:
            return collection.find_one(query, projection)
        return collection.find_one(query)
    except Exception as e:
        logger.error(f"‚ùå Legacy safe_find_one error: {str(e)}")
        return None

def safe_update_one(collection, query, update_data, upsert=False):
    """Legacy wrapper for backwards compatibility"""
    try:
        result = collection.update_one(query, update_data, upsert=upsert)
        return result.acknowledged and (result.modified_count > 0 or result.upserted_id is not None)
    except Exception as e:
        logger.error(f"‚ùå Legacy safe_update_one error: {str(e)}")
        return False

def safe_insert_one(collection, document):
    """Legacy wrapper for backwards compatibility"""
    try:
        result = collection.insert_one(document)
        return result.acknowledged and result.inserted_id is not None
    except Exception as e:
        logger.error(f"‚ùå Legacy safe_insert_one error: {str(e)}")
        return False

# ==========================================
# EXPORTS (ENHANCED)
# ==========================================

__all__ = [
    # NEW CRITICAL FUNCTIONS
    'get_db_connection',           # MISSING FUNCTION - NOW INCLUDED ‚úÖ
    'get_db_connection_with_retry', # MISSING FUNCTION - NOW INCLUDED ‚úÖ
    'test_db_connection',          # MISSING FUNCTION - NOW INCLUDED ‚úÖ
    
    # YOUR EXISTING FUNCTIONS (MAINTAINED)
    'DatabaseHelper', 
    'get_server_collection', 
    'ensure_indexes',
    
    # ENHANCED FUNCTIONS
    'create_database_helper',
    'get_database_health_status',
    
    # LEGACY COMPATIBILITY
    'safe_find_one',
    'safe_update_one', 
    'safe_insert_one'
]