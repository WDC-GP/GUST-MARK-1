"""
"""
"""
Database helper functions for GUST Bot Enhanced
Consolidates repeated database operation patterns across the project
Generated by GUST-MARK-1 optimization script on 06/18/2025 17:56:44

This module provides standardized database operations with proper
error handling, logging, and consistent patterns.
"""

# Standard library imports
from datetime import datetime
import logging

# Third-party imports
from bson import ObjectId
from pymongo.errors import PyMongoError, DuplicateKeyError, ConnectionFailure

# Other imports
from typing import Dict, List, Optional, Any


# GUST database optimization imports
from utils.gust_db_optimization import (
    get_user_with_cache,
    get_user_balance_cached,
    update_user_balance,
    db_performance_monitor
)


logger = logging.getLogger(__name__)

class DatabaseHelper:
    """Centralized database operations with error handling and logging"""
    
    def __init__(self, db_connection=None):
        self.db = db_connection
        self.logger = logger
    
    def safe_find_one(self, collection, query: Dict, default: Any = None) -> Optional[Dict]:
        """
        Safely find one document with comprehensive error handling
        
        Args:
            collection: MongoDB collection object
            query: MongoDB query dictionary
            default: Default value if document not found or error occurs
            
        Returns:
            Document dictionary or default value
        """
        try:
            result = collection.find_one(query)
            if result:
                self.logger.debug(f"Found document in {collection.name} with query: {query}")
                return result
            else:
                self.logger.debug(f"No document found in {collection.name} with query: {query}")
                return default
        except PyMongoError as e:
            self.logger.error(f"Database find_one error in {collection.name}: {e}")
            return default
        except Exception as e:
            self.logger.error(f"Unexpected error in find_one: {e}")
            return default
    
    def safe_insert_one(self, collection, document: Dict) -> Optional[str]:
        """
        Safely insert document with error handling
        
        Args:
            collection: MongoDB collection object
            document: Document to insert
            
        Returns:
            Inserted document ID as string or None if failed
        """
        try:
            # Add timestamp if not present
            if 'created_at' not in document:
                document['created_at'] = datetime.utcnow()
            
            result = collection.insert_one(document)
            self.logger.info(f"Successfully inserted document in {collection.name}: {result.inserted_id}")
            return str(result.inserted_id)
        except DuplicateKeyError as e:
            self.logger.warning(f"Duplicate key error in {collection.name}: {e}")
            return None
        except PyMongoError as e:
            self.logger.error(f"Database insert error in {collection.name}: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Unexpected error in insert_one: {e}")
            return None
    
    def safe_update_one(self, collection, query: Dict, update: Dict, upsert: bool = False) -> bool:
        """
        Safely update one document with error handling
        
        Args:
            collection: MongoDB collection object
            query: MongoDB query to find document
            update: Update operations dictionary
            upsert: Whether to insert if document doesn't exist
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Add timestamp to update
            if '' in update:
                update['']['updated_at'] = datetime.utcnow()
            else:
                update[''] = {'updated_at': datetime.utcnow()}
            
            result = collection.update_one(query, update, upsert=upsert)
            
            if result.modified_count > 0 or (upsert and result.upserted_id):
                self.logger.info(f"Successfully updated document in {collection.name}")
                return True
            else:
                self.logger.warning(f"No document updated in {collection.name} with query: {query}")
                return False
                
        except PyMongoError as e:
            self.logger.error(f"Database update error in {collection.name}: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in update_one: {e}")
            return False
    
    def safe_delete_one(self, collection, query: Dict) -> bool:
        """
        Safely delete one document with error handling
        
        Args:
            collection: MongoDB collection object
            query: MongoDB query to find document to delete
            
        Returns:
            True if successful, False otherwise
        """
        try:
            result = collection.delete_one(query)
            if result.deleted_count > 0:
                self.logger.info(f"Successfully deleted document from {collection.name}")
                return True
            else:
                self.logger.warning(f"No document deleted from {collection.name} with query: {query}")
                return False
        except PyMongoError as e:
            self.logger.error(f"Database delete error in {collection.name}: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in delete_one: {e}")
            return False
    
    def safe_find_many(self, collection, query: Dict, sort: Optional[List] = None, limit: Optional[int] = None) -> List[Dict]:
        """
        Safely find multiple documents with error handling
        
        Args:
            collection: MongoDB collection object
            query: MongoDB query dictionary
            sort: Sort parameters
            limit: Maximum number of documents to return
            
        Returns:
            List of documents or empty list if error
        """
        try:
            cursor = collection.find(query)
            
            if sort:
                cursor = cursor.sort(sort)
            if limit:
                cursor = cursor.limit(limit)
            
            results = list(cursor)
            self.logger.debug(f"Found {len(results)} documents in {collection.name}")
            return results
            
        except PyMongoError as e:
            self.logger.error(f"Database find_many error in {collection.name}: {e}")
            return []
        except Exception as e:
            self.logger.error(f"Unexpected error in find_many: {e}")
            return []
    
    def validate_object_id(self, id_string: str) -> Optional[ObjectId]:
        """
        Validate and convert string to ObjectId
        
        Args:
            id_string: String representation of ObjectId
            
        Returns:
            ObjectId if valid, None otherwise
        """
        try:
            return ObjectId(id_string)
        except Exception:
            self.logger.warning(f"Invalid ObjectId format: {id_string}")
            return None
    
    def test_connection(self) -> bool:
        """
        Test database connection
        
        Returns:
            True if connection is healthy, False otherwise
        """
        try:
            if self.db:
                self.db.admin.command('ping')
                self.logger.info("Database connection test successful")
                return True
            else:
                self.logger.error("No database connection available")
                return False
        except ConnectionFailure as e:
            self.logger.error(f"Database connection failed: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error in connection test: {e}")
            return False

# Utility functions for common operations
def get_server_collection(db, server_id: str):
    """Get server-specific collection name"""
    return db[f"server_{server_id}"]

def ensure_indexes(collection, indexes: List[Dict]):
    """Ensure indexes exist on collection"""
    try:
        for index in indexes:
            collection.create_index(index.get('keys'), **index.get('options', {}))
        logger.info(f"Indexes ensured for collection {collection.name}")
    except Exception as e:
        logger.error(f"Error ensuring indexes: {e}")

# Export classes and functions
__all__ = [
    'DatabaseHelper', 'get_server_collection', 'ensure_indexes'
]

