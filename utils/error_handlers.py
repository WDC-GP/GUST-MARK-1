"""
Error handling utilities for GUST Bot Enhanced
Provides standardized error handling and logging patterns
Generated by GUST-MARK-1 optimization script on 06/18/2025 17:56:47

This module consolidates error handling patterns and provides
consistent error responses across the application.
"""

import logging
import traceback
import random
from typing import Dict, Optional, Tuple, Any
from datetime import datetime

# Handle Flask import gracefully
try:
    from flask import jsonify, render_template
    FLASK_AVAILABLE = True
except ImportError:
    FLASK_AVAILABLE = False
    jsonify = render_template = None

logger = logging.getLogger(__name__)

class ErrorHandler:
    """Centralized error handling with consistent logging and responses"""
    
    # Standard error codes
    ERROR_CODES = {
        'VALIDATION_ERROR': 400,
        'AUTHENTICATION_ERROR': 401,
        'AUTHORIZATION_ERROR': 403,
        'NOT_FOUND': 404,
        'DUPLICATE_ERROR': 409,
        'DATABASE_ERROR': 500,
        'EXTERNAL_API_ERROR': 502,
        'INTERNAL_ERROR': 500
    }
    
    @staticmethod
    def handle_validation_error(error_message: str, field: Optional[str] = None) -> Tuple[Dict, int]:
        """
        Handle validation errors with standardized response
        
        Args:
            error_message: Human-readable error message
            field: Optional field name that caused the error
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.warning("Validation error [%s]: %s (field: %s)", error_id, error_message, field)
        
        response = {
            'error': True,
            'error_type': 'validation',
            'message': error_message,
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        if field:
            response['field'] = field
        
        return response, ErrorHandler.ERROR_CODES['VALIDATION_ERROR']
    
    @staticmethod
    def handle_authentication_error(error_message: str = "Authentication required") -> Tuple[Dict, int]:
        """
        Handle authentication errors
        
        Args:
            error_message: Custom error message
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.warning("Authentication error [%s]: %s", error_id, error_message)
        
        response = {
            'error': True,
            'error_type': 'authentication',
            'message': error_message,
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        return response, ErrorHandler.ERROR_CODES['AUTHENTICATION_ERROR']
    
    @staticmethod
    def handle_authorization_error(error_message: str = "Insufficient privileges") -> Tuple[Dict, int]:
        """
        Handle authorization/permission errors
        
        Args:
            error_message: Custom error message
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.warning("Authorization error [%s]: %s", error_id, error_message)
        
        response = {
            'error': True,
            'error_type': 'authorization',
            'message': error_message,
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        return response, ErrorHandler.ERROR_CODES['AUTHORIZATION_ERROR']
    
    @staticmethod
    def handle_database_error(error: Exception, operation: str = "database operation") -> Tuple[Dict, int]:
        """
        Handle database-related errors with detailed logging
        
        Args:
            error: The exception that occurred
            operation: Description of the database operation
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.error("Database error [%s] during %s: %s", error_id, operation, str(error))
        logger.debug("Database error stack trace [%s]: %s", error_id, traceback.format_exc())
        
        response = {
            'error': True,
            'error_type': 'database',
            'message': "Database error during " + operation,
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        return response, ErrorHandler.ERROR_CODES['DATABASE_ERROR']
    
    @staticmethod
    def handle_external_api_error(error: Exception, api_name: str = "external API") -> Tuple[Dict, int]:
        """
        Handle external API errors (G-Portal, etc.)
        
        Args:
            error: The exception that occurred
            api_name: Name of the external API
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.error("External API error [%s] with %s: %s", error_id, api_name, str(error))
        
        response = {
            'error': True,
            'error_type': 'external_api',
            'message': "Error communicating with " + api_name,
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        return response, ErrorHandler.ERROR_CODES['EXTERNAL_API_ERROR']
    
    @staticmethod
    def handle_not_found_error(resource: str = "resource") -> Tuple[Dict, int]:
        """
        Handle not found errors
        
        Args:
            resource: Name of the resource that wasn't found
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.info("Not found error [%s]: %s", error_id, resource)
        
        response = {
            'error': True,
            'error_type': 'not_found',
            'message': resource.capitalize() + " not found",
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        return response, ErrorHandler.ERROR_CODES['NOT_FOUND']
    
    @staticmethod
    def handle_duplicate_error(resource: str = "resource") -> Tuple[Dict, int]:
        """
        Handle duplicate resource errors
        
        Args:
            resource: Name of the resource that's duplicated
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.warning("Duplicate error [%s]: %s", error_id, resource)
        
        response = {
            'error': True,
            'error_type': 'duplicate',
            'message': resource.capitalize() + " already exists",
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        return response, ErrorHandler.ERROR_CODES['DUPLICATE_ERROR']
    
    @staticmethod
    def handle_internal_error(error: Exception, context: str = "application") -> Tuple[Dict, int]:
        """
        Handle unexpected internal errors
        
        Args:
            error: The exception that occurred
            context: Context where the error occurred
            
        Returns:
            Tuple of (response_dict, status_code)
        """
        error_id = ErrorHandler._generate_error_id()
        
        logger.error("Internal error [%s] in %s: %s", error_id, context, str(error))
        logger.debug("Internal error stack trace [%s]: %s", error_id, traceback.format_exc())
        
        response = {
            'error': True,
            'error_type': 'internal',
            'message': "An internal error occurred",
            'error_id': error_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        return response, ErrorHandler.ERROR_CODES['INTERNAL_ERROR']
    
    @staticmethod
    def _generate_error_id() -> str:
        """Generate unique error ID for tracking"""
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        random_suffix = random.randint(1000, 9999)
        return "ERR_" + timestamp + "_" + str(random_suffix)

# Decorator for automatic error handling
def handle_errors(f):
    """
    Decorator to automatically handle common exceptions in route functions
    """
    from functools import wraps
    
    @wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except ValueError as e:
            response, status = ErrorHandler.handle_validation_error(str(e))
            if FLASK_AVAILABLE:
                return jsonify(response), status
            else:
                return response, status
        except PermissionError as e:
            response, status = ErrorHandler.handle_authorization_error(str(e))
            if FLASK_AVAILABLE:
                return jsonify(response), status
            else:
                return response, status
        except FileNotFoundError as e:
            response, status = ErrorHandler.handle_not_found_error("file")
            if FLASK_AVAILABLE:
                return jsonify(response), status
            else:
                return response, status
        except Exception as e:
            response, status = ErrorHandler.handle_internal_error(e, f.__name__)
            if FLASK_AVAILABLE:
                return jsonify(response), status
            else:
                return response, status
    
    return decorated_function

# Utility functions for common error patterns
def safe_execute(operation, error_context: str = "operation"):
    """
    Safely execute an operation and return (success, result, error)
    
    Args:
        operation: Function to execute
        error_context: Context description for logging
        
    Returns:
        Tuple of (success: bool, result: Any, error_response: Optional[Tuple])
    """
    try:
        result = operation()
        return True, result, None
    except Exception as e:
        error_response = ErrorHandler.handle_internal_error(e, error_context)
        return False, None, error_response

def create_success_response(data: Any, message: str = "Success") -> Dict:
    """
    Create standardized success response
    
    Args:
        data: Response data
        message: Success message
        
    Returns:
        Standardized success response dictionary
    """
    return {
        'error': False,
        'message': message,
        'data': data,
        'timestamp': datetime.utcnow().isoformat()
    }

# Export error handling classes and functions
__all__ = [
    'ErrorHandler', 'handle_errors', 'safe_execute', 'create_success_response'
]
